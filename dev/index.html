<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · GBModels.jl</title><meta name="title" content="Home · GBModels.jl"/><meta property="og:title" content="Home · GBModels.jl"/><meta property="twitter:title" content="Home · GBModels.jl"/><meta name="description" content="Documentation for GBModels.jl."/><meta property="og:description" content="Documentation for GBModels.jl."/><meta property="twitter:description" content="Documentation for GBModels.jl."/><meta property="og:url" content="https://GenomicBreeding.github.io/GBModels.jl/"/><meta property="twitter:url" content="https://GenomicBreeding.github.io/GBModels.jl/"/><link rel="canonical" href="https://GenomicBreeding.github.io/GBModels.jl/"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>GBModels.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/GenomicBreeding/GBModels.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/GenomicBreeding/GBModels.jl/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="GBModels"><a class="docs-heading-anchor" href="#GBModels">GBModels</a><a id="GBModels-1"></a><a class="docs-heading-anchor-permalink" href="#GBModels" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/GenomicBreeding/GBModels.jl">GBModels</a>.</p><ul><li><a href="#GBModels.LπDist"><code>GBModels.LπDist</code></a></li><li><a href="#GBModels.NπDist"><code>GBModels.NπDist</code></a></li><li><a href="#GBModels.TπDist"><code>GBModels.TπDist</code></a></li><li><a href="#Base.maximum-Tuple{GBModels.NπDist}"><code>Base.maximum</code></a></li><li><a href="#Base.maximum-Tuple{GBModels.LπDist}"><code>Base.maximum</code></a></li><li><a href="#Base.maximum-Tuple{GBModels.TπDist}"><code>Base.maximum</code></a></li><li><a href="#Base.minimum-Tuple{GBModels.LπDist}"><code>Base.minimum</code></a></li><li><a href="#Base.minimum-Tuple{GBModels.NπDist}"><code>Base.minimum</code></a></li><li><a href="#Base.minimum-Tuple{GBModels.TπDist}"><code>Base.minimum</code></a></li><li><a href="#Base.rand-Tuple{Random.AbstractRNG, GBModels.TπDist}"><code>Base.rand</code></a></li><li><a href="#Base.rand-Tuple{Random.AbstractRNG, GBModels.NπDist}"><code>Base.rand</code></a></li><li><a href="#Base.rand-Tuple{Random.AbstractRNG, GBModels.LπDist}"><code>Base.rand</code></a></li><li><a href="#Distributions.logpdf-Tuple{GBModels.NπDist, Real}"><code>Distributions.logpdf</code></a></li><li><a href="#Distributions.logpdf-Tuple{GBModels.LπDist, Real}"><code>Distributions.logpdf</code></a></li><li><a href="#Distributions.logpdf-Tuple{GBModels.TπDist, Real}"><code>Distributions.logpdf</code></a></li><li><a href="#GBModels.addnorm-Tuple{Any, Any}"><code>GBModels.addnorm</code></a></li><li><a href="#GBModels.bayesa-Tuple{}"><code>GBModels.bayesa</code></a></li><li><a href="#GBModels.bayesb-Tuple{}"><code>GBModels.bayesb</code></a></li><li><a href="#GBModels.bayesc-Tuple{}"><code>GBModels.bayesc</code></a></li><li><a href="#GBModels.bayesian-Tuple{String}"><code>GBModels.bayesian</code></a></li><li><a href="#GBModels.bayesian-Tuple{Function}"><code>GBModels.bayesian</code></a></li><li><a href="#GBModels.bglr-Tuple{}"><code>GBModels.bglr</code></a></li><li><a href="#GBModels.cvbulk-Tuple{}"><code>GBModels.cvbulk</code></a></li><li><a href="#GBModels.cvleaveonepopulationout-Tuple{}"><code>GBModels.cvleaveonepopulationout</code></a></li><li><a href="#GBModels.cvmultithread!-Tuple{Vector{GBCore.CV}}"><code>GBModels.cvmultithread!</code></a></li><li><a href="#GBModels.cvpairwisepopulation-Tuple{}"><code>GBModels.cvpairwisepopulation</code></a></li><li><a href="#GBModels.cvperpopulation-Tuple{}"><code>GBModels.cvperpopulation</code></a></li><li><a href="#GBModels.epistasisfeatures-Tuple{GBCore.Genomes, GBCore.Phenomes}"><code>GBModels.epistasisfeatures</code></a></li><li><a href="#GBModels.extractxyetc-Tuple{GBCore.Genomes, GBCore.Phenomes}"><code>GBModels.extractxyetc</code></a></li><li><a href="#GBModels.grmploidyaware-Tuple{GBCore.Genomes}"><code>GBModels.grmploidyaware</code></a></li><li><a href="#GBModels.grmsimple-Tuple{GBCore.Genomes}"><code>GBModels.grmsimple</code></a></li><li><a href="#GBModels.gwaslmm-Tuple{GBCore.Genomes, GBCore.Phenomes}"><code>GBModels.gwaslmm</code></a></li><li><a href="#GBModels.gwasols-Tuple{GBCore.Genomes, GBCore.Phenomes}"><code>GBModels.gwasols</code></a></li><li><a href="#GBModels.gwasprep-Tuple{GBCore.Genomes, GBCore.Phenomes}"><code>GBModels.gwasprep</code></a></li><li><a href="#GBModels.gwasreml-Tuple{GBCore.Genomes, GBCore.Phenomes}"><code>GBModels.gwasreml</code></a></li><li><a href="#GBModels.invoneplus-Tuple{Any}"><code>GBModels.invoneplus</code></a></li><li><a href="#GBModels.lasso-Tuple{}"><code>GBModels.lasso</code></a></li><li><a href="#GBModels.log10epsdivlog10eps-Tuple{Any}"><code>GBModels.log10epsdivlog10eps</code></a></li><li><a href="#GBModels.loglikreml-Tuple{Vector{Float64}, Tuple{Vector{Float64}, Matrix{Float64}, Matrix{Float64}}}"><code>GBModels.loglikreml</code></a></li><li><a href="#GBModels.mult-Tuple{Any, Any}"><code>GBModels.mult</code></a></li><li><a href="#GBModels.ols-Tuple{}"><code>GBModels.ols</code></a></li><li><a href="#GBModels.predict-Tuple{}"><code>GBModels.predict</code></a></li><li><a href="#GBModels.raise-Tuple{Any, Any}"><code>GBModels.raise</code></a></li><li><a href="#GBModels.reconstitutefeatures-Tuple{GBCore.Genomes}"><code>GBModels.reconstitutefeatures</code></a></li><li><a href="#GBModels.ridge-Tuple{}"><code>GBModels.ridge</code></a></li><li><a href="#GBModels.square-Tuple{Any}"><code>GBModels.square</code></a></li><li><a href="#GBModels.transform1-Tuple{Function, GBCore.Genomes, GBCore.Phenomes}"><code>GBModels.transform1</code></a></li><li><a href="#GBModels.transform2-Tuple{Function, GBCore.Genomes, GBCore.Phenomes}"><code>GBModels.transform2</code></a></li><li><a href="#GBModels.turing_bayesG-Tuple{Any, Any}"><code>GBModels.turing_bayesG</code></a></li><li><a href="#GBModels.turing_bayesG_logit-Tuple{Any, Any}"><code>GBModels.turing_bayesG_logit</code></a></li><li><a href="#GBModels.turing_bayesGs-Tuple{Any, Any}"><code>GBModels.turing_bayesGs</code></a></li><li><a href="#GBModels.turing_bayesGπ-Tuple{Any, Any}"><code>GBModels.turing_bayesGπ</code></a></li><li><a href="#GBModels.turing_bayesGπs-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, DynamicPPL.TypeWrap{T}}} where T"><code>GBModels.turing_bayesGπs</code></a></li><li><a href="#GBModels.turing_bayesL-Tuple{Any, Any}"><code>GBModels.turing_bayesL</code></a></li><li><a href="#GBModels.turing_bayesLs-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, DynamicPPL.TypeWrap{T}}} where T"><code>GBModels.turing_bayesLs</code></a></li><li><a href="#GBModels.turing_bayesLπ-Tuple{Any, Any}"><code>GBModels.turing_bayesLπ</code></a></li><li><a href="#GBModels.turing_bayesLπs-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, DynamicPPL.TypeWrap{T}}} where T"><code>GBModels.turing_bayesLπs</code></a></li><li><a href="#GBModels.turing_bayesT-Tuple{Any, Any}"><code>GBModels.turing_bayesT</code></a></li><li><a href="#GBModels.turing_bayesTπ-Tuple{Any, Any}"><code>GBModels.turing_bayesTπ</code></a></li><li><a href="#GBModels.validate-Tuple{GBCore.Fit, GBCore.Genomes, GBCore.Phenomes}"><code>GBModels.validate</code></a></li><li><a href="#GBModels.@string2operations-Tuple{Any}"><code>GBModels.@string2operations</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.LπDist" href="#GBModels.LπDist"><code>GBModels.LπDist</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Laplace distribution with a point mass at 0.0</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/0d7695b86e4b451d4d07d075757f006e48cf6ca2/src/bayes.jl#L514-L516">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.NπDist" href="#GBModels.NπDist"><code>GBModels.NπDist</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Gaussian distribution with a point mass at 0.0</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/0d7695b86e4b451d4d07d075757f006e48cf6ca2/src/bayes.jl#L281-L283">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.TπDist" href="#GBModels.TπDist"><code>GBModels.TπDist</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>T-distribution with a point mass at 0.0</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/0d7695b86e4b451d4d07d075757f006e48cf6ca2/src/bayes.jl#L703-L705">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.maximum-Tuple{GBModels.LπDist}" href="#Base.maximum-Tuple{GBModels.LπDist}"><code>Base.maximum</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Maximum value of the LπDist distribution</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/0d7695b86e4b451d4d07d075757f006e48cf6ca2/src/bayes.jl#L566-L568">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.maximum-Tuple{GBModels.NπDist}" href="#Base.maximum-Tuple{GBModels.NπDist}"><code>Base.maximum</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Maximum value of the NπDist distribution</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/0d7695b86e4b451d4d07d075757f006e48cf6ca2/src/bayes.jl#L333-L335">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.maximum-Tuple{GBModels.TπDist}" href="#Base.maximum-Tuple{GBModels.TπDist}"><code>Base.maximum</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Maximum value of the TπDist distribution</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/0d7695b86e4b451d4d07d075757f006e48cf6ca2/src/bayes.jl#L754-L756">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.minimum-Tuple{GBModels.LπDist}" href="#Base.minimum-Tuple{GBModels.LπDist}"><code>Base.minimum</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Minimum value of the LπDist distribution</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/0d7695b86e4b451d4d07d075757f006e48cf6ca2/src/bayes.jl#L561-L563">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.minimum-Tuple{GBModels.NπDist}" href="#Base.minimum-Tuple{GBModels.NπDist}"><code>Base.minimum</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Minimum value of the NπDist distribution</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/0d7695b86e4b451d4d07d075757f006e48cf6ca2/src/bayes.jl#L328-L330">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.minimum-Tuple{GBModels.TπDist}" href="#Base.minimum-Tuple{GBModels.TπDist}"><code>Base.minimum</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Minimum value of the TπDist distribution</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/0d7695b86e4b451d4d07d075757f006e48cf6ca2/src/bayes.jl#L749-L751">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.rand-Tuple{Random.AbstractRNG, GBModels.LπDist}" href="#Base.rand-Tuple{Random.AbstractRNG, GBModels.LπDist}"><code>Base.rand</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Sampling method for LπDist</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">d = LπDist(0.1, 0.0, 1.0)
rand(d)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/0d7695b86e4b451d4d07d075757f006e48cf6ca2/src/bayes.jl#L523-L531">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.rand-Tuple{Random.AbstractRNG, GBModels.NπDist}" href="#Base.rand-Tuple{Random.AbstractRNG, GBModels.NπDist}"><code>Base.rand</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Sampling method for NπDist</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">d = NπDist(0.1, 0.0, 1.0)
rand(d)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/0d7695b86e4b451d4d07d075757f006e48cf6ca2/src/bayes.jl#L290-L298">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.rand-Tuple{Random.AbstractRNG, GBModels.TπDist}" href="#Base.rand-Tuple{Random.AbstractRNG, GBModels.TπDist}"><code>Base.rand</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Sampling method for TπDist</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">d = TπDist(0.1, 1.0)
rand(d)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/0d7695b86e4b451d4d07d075757f006e48cf6ca2/src/bayes.jl#L711-L719">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Distributions.logpdf-Tuple{GBModels.LπDist, Real}" href="#Distributions.logpdf-Tuple{GBModels.LπDist, Real}"><code>Distributions.logpdf</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>log(pdf) of LπDist</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">d = LπDist(0.1, 0.0, 1.0)
logpdf.(d, [-1.0, 0.0, 1.0])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/0d7695b86e4b451d4d07d075757f006e48cf6ca2/src/bayes.jl#L542-L550">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Distributions.logpdf-Tuple{GBModels.NπDist, Real}" href="#Distributions.logpdf-Tuple{GBModels.NπDist, Real}"><code>Distributions.logpdf</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>log(pdf) of NπDist</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">d = NπDist(0.1, 0.0, 1.0)
logpdf.(d, [-1.0, 0.0, 1.0])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/0d7695b86e4b451d4d07d075757f006e48cf6ca2/src/bayes.jl#L309-L317">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Distributions.logpdf-Tuple{GBModels.TπDist, Real}" href="#Distributions.logpdf-Tuple{GBModels.TπDist, Real}"><code>Distributions.logpdf</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>log(pdf) of TπDist</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">d = TπDist(0.1, 1.0)
logpdf.(d, [-1.0, 0.0, 1.0])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/0d7695b86e4b451d4d07d075757f006e48cf6ca2/src/bayes.jl#L730-L738">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.addnorm-Tuple{Any, Any}" href="#GBModels.addnorm-Tuple{Any, Any}"><code>GBModels.addnorm</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">addnorm(x, y) = (x + y) / 2.0</code></pre><p>An endofunction within the zero to one domain which accepts two inputs, and divides their sum by two.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/0d7695b86e4b451d4d07d075757f006e48cf6ca2/src/transformation.jl#L30-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.bayesa-Tuple{}" href="#GBModels.bayesa-Tuple{}"><code>GBModels.bayesa</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bayesa(;
    genomes::Genomes,
    phenomes::Phenomes,
    idx_entries::Union{Nothing,Vector{Int64}} = nothing,
    idx_loci_alleles::Union{Nothing,Vector{Int64}} = nothing,
    idx_trait::Int64 = 1,
    verbose::Bool = false,
)::Fit</code></pre><p>Fit a Bayes A model via BGLR</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GBCore.simulategenomes(verbose=false);

julia&gt; trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);;

julia&gt; phenomes = extractphenomes(trials);

julia&gt; fit = bayesa(genomes=genomes, phenomes=phenomes);

julia&gt; fit.model == &quot;bayesa&quot;
true

julia&gt; fit.metrics[&quot;cor&quot;] &gt; 0.50
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/0d7695b86e4b451d4d07d075757f006e48cf6ca2/src/linear.jl#L298-L326">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.bayesb-Tuple{}" href="#GBModels.bayesb-Tuple{}"><code>GBModels.bayesb</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bayesb(;
    genomes::Genomes,
    phenomes::Phenomes,
    idx_entries::Union{Nothing,Vector{Int64}} = nothing,
    idx_loci_alleles::Union{Nothing,Vector{Int64}} = nothing,
    idx_trait::Int64 = 1,
    verbose::Bool = false,
)::Fit</code></pre><p>Fit a Bayes A model via BGLR</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GBCore.simulategenomes(verbose=false);

julia&gt; trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);;

julia&gt; phenomes = extractphenomes(trials);

julia&gt; fit = bayesb(genomes=genomes, phenomes=phenomes);

julia&gt; fit.model == &quot;bayesb&quot;
true

julia&gt; fit.metrics[&quot;cor&quot;] &gt; 0.50
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/0d7695b86e4b451d4d07d075757f006e48cf6ca2/src/linear.jl#L350-L378">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.bayesc-Tuple{}" href="#GBModels.bayesc-Tuple{}"><code>GBModels.bayesc</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bayesc(;
    genomes::Genomes,
    phenomes::Phenomes,
    idx_entries::Union{Nothing,Vector{Int64}} = nothing,
    idx_loci_alleles::Union{Nothing,Vector{Int64}} = nothing,
    idx_trait::Int64 = 1,
    verbose::Bool = false,
)::Fit</code></pre><p>Fit a Bayes A model via BGLR</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GBCore.simulategenomes(verbose=false);

julia&gt; trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);;

julia&gt; phenomes = extractphenomes(trials);

julia&gt; fit = bayesc(genomes=genomes, phenomes=phenomes);

julia&gt; fit.model == &quot;bayesc&quot;
true

julia&gt; fit.metrics[&quot;cor&quot;] &gt; 0.50
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/0d7695b86e4b451d4d07d075757f006e48cf6ca2/src/linear.jl#L402-L430">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.bayesian-Tuple{Function}" href="#GBModels.bayesian-Tuple{Function}"><code>GBModels.bayesian</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bayesian(
    turing_model::Function;
    X::Matrix{Float64},
    y::Vector{Float64},
    sampler::String = [&quot;NUTS&quot;, &quot;HMC&quot;, &quot;HMCDA&quot;, &quot;MH&quot;, &quot;PG&quot;][1],
    sampling_method::Int64 = 1,
    seed::Int64 = 123,
    n_burnin::Int64 = 500,
    n_iter::Int64 = 1_500,
    verbose::Bool = false,
)::Fit</code></pre><p>Fit a Bayesian linear regression models via Turing.jl</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GBCore.simulategenomes(verbose=false);

julia&gt; trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);

julia&gt; phenomes = extractphenomes(trials);

julia&gt; sol = Suppressor.@suppress bayesian(turing_bayesG, genomes=genomes, phenomes=phenomes);

julia&gt; # Slow because not multivariate T-dist: sol_T = Suppressor.@suppress bayesian(turing_bayesT, genomes=genomes, phenomes=phenomes);

julia&gt; # Even slower because of an extra set of distribution to define a non-spherical variance-covariance matrix: sol_Gs = Suppressor.@suppress bayesian(turing_bayesGs, genomes=genomes, phenomes=phenomes);

julia&gt; sol_BGLR = Suppressor.@suppress bayesian(&quot;BayesA&quot;, genomes=genomes, phenomes=phenomes); sol.metrics[&quot;cor&quot;] &gt; sol_BGLR.metrics[&quot;cor&quot;]
true

julia&gt; sol.metrics[&quot;cor&quot;] &gt; 0.5
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/0d7695b86e4b451d4d07d075757f006e48cf6ca2/src/bayes.jl#L819-L854">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.bayesian-Tuple{String}" href="#GBModels.bayesian-Tuple{String}"><code>GBModels.bayesian</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bayesian(
    bglr_model::String;
    X::Matrix{Float64},
    y::Vector{Float64},
    n_burnin::Int64 = 500,
    n_iter::Int64 = 1_500,
    verbose::Bool = false,
)::Fit</code></pre><p>Fit a Bayesian linear regression models via BGLR in R</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GBCore.simulategenomes(verbose=false);

julia&gt; trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);

julia&gt; phenomes = extractphenomes(trials);

julia&gt; sol = Suppressor.@suppress bayesian(&quot;BayesA&quot;, genomes=genomes, phenomes=phenomes);

julia&gt; sol.metrics[&quot;cor&quot;] &gt; 0.5
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/0d7695b86e4b451d4d07d075757f006e48cf6ca2/src/bayes.jl#L79-L104">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.bglr-Tuple{}" href="#GBModels.bglr-Tuple{}"><code>GBModels.bglr</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Bayesian models using BGLR, i.e. Bayes A, Bayes B and Bayes C</p><p>Note that this is hacky. It invokes Rscript for each instance which should allow multi-threading where RCall.jl currently does not.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/0d7695b86e4b451d4d07d075757f006e48cf6ca2/src/bayes.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.cvbulk-Tuple{}" href="#GBModels.cvbulk-Tuple{}"><code>GBModels.cvbulk</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cvbulk(;
    genomes::Genomes,
    phenomes::Phenomes,
    models::Vector{Function}=[ridge],
    n_replications::Int64=5,
    n_folds::Int64=5,
    seed::Int64=42,
    verbose::Bool=true
)::Tuple{Vector{CV}, Vector{String}}</code></pre><p>Bulk (regardless of population groupings) replicated cross-validation of genomic prediction model/s across all available traits. </p><p>Note that to use multiple threads, please invoke Julia as: <code>julia --threads 7,1 --load test/interactive_prelude.jl</code>, where <code>--threads 7,1</code> means use 7 threads for multi-threaded processes while reserving 1 thread for the Julia runtime itself.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GBCore.simulategenomes(verbose=false); genomes.populations = StatsBase.sample(string.(&quot;pop_&quot;, 1:3), length(genomes.entries), replace=true);

julia&gt; trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, verbose=false);

julia&gt; phenomes = extractphenomes(trials);

julia&gt; cvs, notes = cvbulk(genomes=genomes, phenomes=phenomes, models=[ols, ridge], n_replications=2, n_folds=2, verbose=false);

julia&gt; df_across_entries, df_per_entry = tabularise(cvs);

julia&gt; idx_across = findall((df_across_entries.trait .== &quot;trait_1&quot;) .&amp;&amp; (df_across_entries.model .== &quot;ridge&quot;) .&amp;&amp; (df_across_entries.replication .== &quot;replication_1&quot;) .&amp;&amp; (df_across_entries.fold .== &quot;fold_1&quot;));

julia&gt; idx_per = findall((df_per_entry.trait .== &quot;trait_1&quot;) .&amp;&amp; (df_per_entry.model .== &quot;ridge&quot;) .&amp;&amp; (df_per_entry.replication .== &quot;replication_1&quot;) .&amp;&amp; (df_per_entry.fold .== &quot;fold_1&quot;));

julia&gt; abs(df_across_entries.cor[idx_across][1] - cor(df_per_entry.y_true[idx_per], df_per_entry.y_pred[idx_per])) &lt; 1e-10
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/0d7695b86e4b451d4d07d075757f006e48cf6ca2/src/cross_validation.jl#L169-L204">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.cvleaveonepopulationout-Tuple{}" href="#GBModels.cvleaveonepopulationout-Tuple{}"><code>GBModels.cvleaveonepopulationout</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cvleaveonepopulationout(;
    genomes::Genomes,
    phenomes::Phenomes,
    models::Vector{Function}=[ridge],
    n_replications::Int64=5,
    n_folds::Int64=5,
    seed::Int64=42,
    verbose::Bool=true
)::Tuple{Vector{CV}, Vector{String}}</code></pre><p>Leave-one-population-out cross-validation of genomic prediction model/s across all available traits.</p><p>Note that to use multiple threads, please invoke Julia as: <code>julia --threads 7,1 --load test/interactive_prelude.jl</code>, where <code>--threads 7,1</code> means use 7 threads for multi-threaded processes while reserving 1 thread for the Julia runtime itself.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GBCore.simulategenomes(verbose=false); genomes.populations = StatsBase.sample(string.(&quot;pop_&quot;, 1:3), length(genomes.entries), replace=true);

julia&gt; trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);

julia&gt; phenomes = extractphenomes(trials);

julia&gt; cvs, notes = cvleaveonepopulationout(genomes=genomes, phenomes=phenomes, models=[ridge, bayesa], n_replications=2, n_folds=2, verbose=false);

julia&gt; df_across_entries, df_per_entry = tabularise(cvs);

julia&gt; sum([sum(split(df_across_entries.training_population[i], &quot;;&quot;) .== df_across_entries.validation_population[i]) for i in 1:size(df_across_entries, 1)]) == 0
true

julia&gt; idx_across = findall((df_across_entries.validation_population .== &quot;pop_1&quot;) .&amp;&amp; (df_across_entries.trait .== &quot;trait_1&quot;) .&amp;&amp; (df_across_entries.model .== &quot;ridge&quot;));

julia&gt; idx_per = findall((df_per_entry.validation_population .== &quot;pop_1&quot;) .&amp;&amp; (df_per_entry.trait .== &quot;trait_1&quot;) .&amp;&amp; (df_per_entry.model .== &quot;ridge&quot;));

julia&gt; abs(df_across_entries.cor[idx_across][1] - cor(df_per_entry.y_true[idx_per], df_per_entry.y_pred[idx_per])) &lt; 1e-10
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/0d7695b86e4b451d4d07d075757f006e48cf6ca2/src/cross_validation.jl#L706-L744">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.cvmultithread!-Tuple{Vector{GBCore.CV}}" href="#GBModels.cvmultithread!-Tuple{Vector{GBCore.CV}}"><code>GBModels.cvmultithread!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cvmultithread!(cvs::Vector{CV}; genomes::Genomes, phenomes::Phenomes, models::Vector{Function})</code></pre><p>Multi-threded generic genomic prediction cross-validation </p><p>Note that to use multiple threads, please invoke Julia as: <code>julia --threads 7,1 --load test/interactive_prelude.jl</code>, where <code>--threads 7,1</code> means use 7 threads for multi-threaded processes while reserving 1 thread for the Julia runtime itself.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GBCore.simulategenomes(verbose=false);

julia&gt; trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);

julia&gt; phenomes = extractphenomes(trials);

julia&gt; idx_training = collect(1:50);

julia&gt; idx_validation_1 = collect(51:75);

julia&gt; idx_validation_2 = collect(76:100);

julia&gt; fit = Fit(n = length(idx_training), l = length(genomes.loci_alleles) + 1); fit.model = &quot;ridge&quot;; fit.trait = &quot;trait_1&quot;; 

julia&gt; fit.entries = genomes.entries[idx_training]; fit.populations = genomes.populations[idx_training]; 

julia&gt; fit.b_hat_labels = vcat([&quot;intercept&quot;], genomes.loci_alleles);

julia&gt; cv_1 = CV(&quot;replication_1&quot;, &quot;fold_1&quot;, fit, genomes.populations[idx_validation_1], genomes.entries[idx_validation_1], zeros(length(idx_validation_1)), zeros(length(idx_validation_1)), fit.metrics);

julia&gt; cv_2 = CV(&quot;replication_1&quot;, &quot;fold_2&quot;, fit, genomes.populations[idx_validation_2], genomes.entries[idx_validation_2], zeros(length(idx_validation_2)), zeros(length(idx_validation_2)), fit.metrics);

julia&gt; cvs = [cv_1, cv_2]; models = [ridge, ridge];

julia&gt; cvmultithread!(cvs, genomes=genomes, phenomes=phenomes, models_vector=[ridge, bayesa], verbose=false);

julia&gt; df_across_entries, df_per_entry = tabularise(cvs);

julia&gt; idx_across = findall(df_across_entries.fold .== &quot;fold_2&quot;);

julia&gt; idx_per = findall(df_per_entry.fold .== &quot;fold_2&quot;);

julia&gt; abs(df_across_entries.cor[idx_across][1] - cor(df_per_entry.y_true[idx_per], df_per_entry.y_pred[idx_per])) &lt; 1e-10
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/0d7695b86e4b451d4d07d075757f006e48cf6ca2/src/cross_validation.jl#L65-L110">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.cvpairwisepopulation-Tuple{}" href="#GBModels.cvpairwisepopulation-Tuple{}"><code>GBModels.cvpairwisepopulation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cvpairwisepopulation(;
    genomes::Genomes,
    phenomes::Phenomes,
    models::Vector{Function}=[ridge],
    n_replications::Int64=5,
    n_folds::Int64=5,
    seed::Int64=42,
    verbose::Bool=true
)::Tuple{Vector{CV}, Vector{String}}</code></pre><p>Pairwise population cross-validation of genomic prediction model/s across all available traits.</p><p>Note that to use multiple threads, please invoke Julia as: <code>julia --threads 7,1 --load test/interactive_prelude.jl</code>, where <code>--threads 7,1</code> means use 7 threads for multi-threaded processes while reserving 1 thread for the Julia runtime itself.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GBCore.simulategenomes(verbose=false); genomes.populations = StatsBase.sample(string.(&quot;pop_&quot;, 1:3), length(genomes.entries), replace=true);

julia&gt; trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);

julia&gt; phenomes = extractphenomes(trials);

julia&gt; cvs, notes = cvpairwisepopulation(genomes=genomes, phenomes=phenomes, models=[ols, ridge], n_replications=2, n_folds=2, verbose=false);

julia&gt; df_across_entries, df_per_entry = tabularise(cvs);

julia&gt; sum(df_across_entries.training_population .!= df_across_entries.validation_population) == size(df_across_entries, 1)
true

julia&gt; idx_across = findall((df_across_entries.training_population .== &quot;pop_1&quot;) .&amp;&amp; (df_across_entries.validation_population .== &quot;pop_2&quot;) .&amp;&amp; (df_across_entries.trait .== &quot;trait_1&quot;) .&amp;&amp; (df_across_entries.model .== &quot;ridge&quot;));

julia&gt; idx_per = findall((df_per_entry.training_population .== &quot;pop_1&quot;) .&amp;&amp; (df_per_entry.validation_population .== &quot;pop_2&quot;) .&amp;&amp; (df_per_entry.trait .== &quot;trait_1&quot;) .&amp;&amp; (df_per_entry.model .== &quot;ridge&quot;));

julia&gt; abs(df_across_entries.cor[idx_across][1] - cor(df_per_entry.y_true[idx_per], df_per_entry.y_pred[idx_per])) &lt; 1e-10
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/0d7695b86e4b451d4d07d075757f006e48cf6ca2/src/cross_validation.jl#L506-L544">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.cvperpopulation-Tuple{}" href="#GBModels.cvperpopulation-Tuple{}"><code>GBModels.cvperpopulation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cvperpopulation(;
    genomes::Genomes,
    phenomes::Phenomes,
    models::Vector{Function}=[ridge],
    n_replications::Int64=5,
    n_folds::Int64=5,
    seed::Int64=42,
    verbose::Bool=true
)::Tuple{Vector{CV}, Vector{String}}</code></pre><p>Within population replicated cross-validation of genomic prediction model/s across all available traits.</p><p>Note that to use multiple threads, please invoke Julia as: <code>julia --threads 7,1 --load test/interactive_prelude.jl</code>, where <code>--threads 7,1</code> means use 7 threads for multi-threaded processes while reserving 1 thread for the Julia runtime itself.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GBCore.simulategenomes(l=1_000, verbose=false); genomes.populations = StatsBase.sample(string.(&quot;pop_&quot;, 1:3), length(genomes.entries), replace=true);

julia&gt; trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);

julia&gt; phenomes = extractphenomes(trials);

julia&gt; cvs, notes = cvperpopulation(genomes=genomes, phenomes=phenomes, models=[ridge, bayesa], n_replications=2, n_folds=2, verbose=false);

julia&gt; df_across_entries, df_per_entry = tabularise(cvs);

julia&gt; sort(unique(df_across_entries.training_population))
3-element Vector{String}:
 &quot;pop_1&quot;
 &quot;pop_2&quot;
 &quot;pop_3&quot;

julia&gt; df_across_entries.training_population == df_across_entries.validation_population
true

julia&gt; idx_across = findall((df_across_entries.validation_population .== &quot;pop_1&quot;) .&amp;&amp; (df_across_entries.trait .== &quot;trait_1&quot;) .&amp;&amp; (df_across_entries.model .== &quot;bayesa&quot;) .&amp;&amp; (df_across_entries.replication .== &quot;replication_1&quot;) .&amp;&amp; (df_across_entries.fold .== &quot;fold_1&quot;));

julia&gt; idx_per = findall((df_per_entry.validation_population .== &quot;pop_1&quot;) .&amp;&amp; (df_per_entry.trait .== &quot;trait_1&quot;) .&amp;&amp; (df_per_entry.model .== &quot;bayesa&quot;) .&amp;&amp; (df_per_entry.replication .== &quot;replication_1&quot;) .&amp;&amp; (df_per_entry.fold .== &quot;fold_1&quot;));

julia&gt; abs(df_across_entries.cor[idx_across][1] - cor(df_per_entry.y_true[idx_per], df_per_entry.y_pred[idx_per])) &lt; 1e-10
true

julia&gt; summary_across, summary_per_entry = summarise(cvs);

julia&gt; size(summary_across)
(6, 6)

julia&gt; size(summary_per_entry)
(200, 8)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/0d7695b86e4b451d4d07d075757f006e48cf6ca2/src/cross_validation.jl#L360-L412">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.epistasisfeatures-Tuple{GBCore.Genomes, GBCore.Phenomes}" href="#GBModels.epistasisfeatures-Tuple{GBCore.Genomes, GBCore.Phenomes}"><code>GBModels.epistasisfeatures</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">epistasisfeatures(
    genomes::Genomes,
    phenomes::Phenomes;
    idx_trait::Int64 = 1,
    idx_entries::Union{Nothing,Vector{Int64}} = nothing,
    idx_loci_alleles::Union{Nothing,Vector{Int64}} = nothing,
    transformations1::Vector{Function} = [square, invoneplus, log10epsdivlog10eps],
    transformations2::Vector{Function} = [mult, addnorm, raise],
    n_new_features_per_transformation::Int64 = 1_000,
    n_reps::Int64 = 3,
    verbose::Bool = false,
)::Genomes</code></pre><p>Generate epistasis features.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GBCore.simulategenomes(l=1_000, verbose=false);

julia&gt; trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);;

julia&gt; phenomes = extractphenomes(trials);

julia&gt; genomes_plus_features = epistasisfeatures(genomes, phenomes, n_new_features_per_transformation=50, n_reps=2, verbose=false);

julia&gt; cvs, notes = cvbulk(genomes=genomes_plus_features, phenomes=phenomes, models=[ridge, lasso, bayesa], verbose=false);

julia&gt; cvs_no_epi, notes_no_epi = cvbulk(genomes=genomes, phenomes=phenomes, models=[ridge, lasso, bayesa], verbose=false);

julia&gt; df_across, df_per_entry = GBCore.tabularise(cvs);

julia&gt; df_across_no_epi, df_per_entry_no_epi = GBCore.tabularise(cvs_no_epi);

julia&gt; df_summary = combine(groupby(df_across, [:trait, :model]), [[:cor] =&gt; mean, [:cor] =&gt; std]);

julia&gt; df_summary_no_epi = combine(groupby(df_across_no_epi, [:trait, :model]), [[:cor] =&gt; mean, [:cor] =&gt; std]);

julia&gt; mean(df_summary.cor_mean) &gt; mean(df_summary_no_epi.cor_mean)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/0d7695b86e4b451d4d07d075757f006e48cf6ca2/src/transformation.jl#L397-L438">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.extractxyetc-Tuple{GBCore.Genomes, GBCore.Phenomes}" href="#GBModels.extractxyetc-Tuple{GBCore.Genomes, GBCore.Phenomes}"><code>GBModels.extractxyetc</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">extractxyetc(
    genomes::Genomes,
    phenomes::Phenomes;
    idx_entries::Union{Nothing,Vector{Int64}} = nothing,
    idx_loci_alleles::Union{Nothing,Vector{Int64}} = nothing,
    idx_trait::Int64 = 1,
    add_intercept::Bool = true,
)::Tuple{Matrix{Float64},Vector{Float64},Vector{String},Vector{String},Vector{String}}</code></pre><p>Extract explanatory <code>X</code> matrix, response <code>y</code> vector, names of the entries, populations and loci-alleles from genomes and phenomes.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GBCore.simulategenomes(verbose=false);

julia&gt; trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);;

julia&gt; phenomes = extractphenomes(trials);

julia&gt; X, y, loci_alleles = extractxyetc(genomes, phenomes);

julia&gt; X == hcat(ones(length(phenomes.entries)), genomes.allele_frequencies)
true

julia&gt; y == phenomes.phenotypes[:, 1]
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/0d7695b86e4b451d4d07d075757f006e48cf6ca2/src/prediction.jl#L1-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.grmploidyaware-Tuple{GBCore.Genomes}" href="#GBModels.grmploidyaware-Tuple{GBCore.Genomes}"><code>GBModels.grmploidyaware</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">grmploidyaware(
    genomes::Genomes;
    ploidy::Int64 = 2,
    idx_entries::Union{Nothing,Vector{Int64}} = nothing,
    idx_loci_alleles::Union{Nothing,Vector{Int64}} = nothing,
    verbose::Bool = false
)::Matrix{Float64}</code></pre><p>Generate a ploidy-aware genetic relationship matrix (see Bell et al (2017) and VanRaden et al (2008)) whose diagonals are likely inflated to allow inversion in dowstream analysis.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GBCore.simulategenomes(verbose=false);

julia&gt; GRM_VanRaden = grmploidyaware(genomes);

julia&gt; size(GRM_VanRaden), issymmetric(GRM_VanRaden)
((100, 100), true)

julia&gt; det(GRM_VanRaden) &gt; eps(Float64)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/0d7695b86e4b451d4d07d075757f006e48cf6ca2/src/grm.jl#L59-L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.grmsimple-Tuple{GBCore.Genomes}" href="#GBModels.grmsimple-Tuple{GBCore.Genomes}"><code>GBModels.grmsimple</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">grmsimple(
    genomes::Genomes;
    idx_entries::Union{Nothing,Vector{Int64}} = nothing,
    idx_loci_alleles::Union{Nothing,Vector{Int64}} = nothing,
    verbose::Bool = false
)::Matrix{Float64}</code></pre><p>Generate a simple genetic relationship matrix whose diagonals are likely inflated to allow inversion in dowstream analysis.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GBCore.simulategenomes(verbose=false);

julia&gt; GRM = grmsimple(genomes);

julia&gt; size(GRM), issymmetric(GRM)
((100, 100), true)

julia&gt; det(GRM) &gt; eps(Float64)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/0d7695b86e4b451d4d07d075757f006e48cf6ca2/src/grm.jl#L1-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.gwaslmm-Tuple{GBCore.Genomes, GBCore.Phenomes}" href="#GBModels.gwaslmm-Tuple{GBCore.Genomes, GBCore.Phenomes}"><code>GBModels.gwaslmm</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gwaslmm(
    genomes::Genomes,
    phenomes::Phenomes;
    idx_entries::Union{Nothing,Vector{Int64}} = nothing,
    idx_loci_alleles::Union{Nothing,Vector{Int64}} = nothing,
    idx_trait::Int64 = 1,
    GRM_type::String = [&quot;simple&quot;, &quot;ploidy-aware&quot;][1],
    verbose::Bool = false,
)::Fit</code></pre><p>Genome-association analysis via linear mixed modelling using the first principal component of the genetic relationship matrix, where the covariance matrix of the genotype effects is unstructured.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GBCore.simulategenomes(verbose=false);

julia&gt; ploidy = 4;

julia&gt; genomes.allele_frequencies = round.(genomes.allele_frequencies .* ploidy) ./ ploidy;

julia&gt; proportion_of_variance = zeros(9, 1); proportion_of_variance[1, 1] = 0.5;

julia&gt; trials, effects = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.05 0.00 0.00;], proportion_of_variance = proportion_of_variance, verbose=false);;

julia&gt; phenomes = extractphenomes(trials);

julia&gt; fit_1 = Suppressor.@suppress gwaslmm(genomes, phenomes, GRM_type=&quot;simple&quot;);

julia&gt; fit_1.model
&quot;GWAS_LMM&quot;

julia&gt; fit_2 = Suppressor.@suppress gwaslmm(genomes, phenomes, GRM_type=&quot;ploidy-aware&quot;);

julia&gt; fit_2.model
&quot;GWAS_LMM&quot;

julia&gt; findall(fit_1.b_hat .== maximum(fit_1.b_hat)) == findall(fit_2.b_hat .== maximum(fit_2.b_hat))
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/0d7695b86e4b451d4d07d075757f006e48cf6ca2/src/gwas.jl#L215-L256">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.gwasols-Tuple{GBCore.Genomes, GBCore.Phenomes}" href="#GBModels.gwasols-Tuple{GBCore.Genomes, GBCore.Phenomes}"><code>GBModels.gwasols</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gwasols(
    genomes::Genomes,
    phenomes::Phenomes;
    idx_entries::Union{Nothing,Vector{Int64}} = nothing,
    idx_loci_alleles::Union{Nothing,Vector{Int64}} = nothing,
    idx_trait::Int64 = 1,
    GRM_type::String = [&quot;simple&quot;, &quot;ploidy-aware&quot;][1],
    verbose::Bool = false,
)::Fit</code></pre><p>Genome-association analysis via ordinary least squares using the first principal component of the  genetic relationship matrix as covariate to account for population structure.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GBCore.simulategenomes(verbose=false);

julia&gt; ploidy = 4;

julia&gt; genomes.allele_frequencies = round.(genomes.allele_frequencies .* ploidy) ./ ploidy;

julia&gt; proportion_of_variance = zeros(9, 1); proportion_of_variance[1, 1] = 0.5;

julia&gt; trials, effects = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.05 0.00 0.00;], proportion_of_variance = proportion_of_variance, verbose=false);;

julia&gt; phenomes = extractphenomes(trials);

julia&gt; fit_1 = gwasols(genomes, phenomes, GRM_type=&quot;simple&quot;);

julia&gt; fit_1.model
&quot;GWAS_OLS&quot;

julia&gt; fit_2 = gwasols(genomes, phenomes, GRM_type=&quot;ploidy-aware&quot;);

julia&gt; fit_2.model
&quot;GWAS_OLS&quot;

julia&gt; findall(fit_1.b_hat .== maximum(fit_1.b_hat)) == findall(fit_2.b_hat .== maximum(fit_2.b_hat))
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/0d7695b86e4b451d4d07d075757f006e48cf6ca2/src/gwas.jl#L118-L159">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.gwasprep-Tuple{GBCore.Genomes, GBCore.Phenomes}" href="#GBModels.gwasprep-Tuple{GBCore.Genomes, GBCore.Phenomes}"><code>GBModels.gwasprep</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gwasprep(
    genomes::Genomes,
    phenomes::Phenomes;
    idx_entries::Union{Nothing,Vector{Int64}} = nothing,
    idx_loci_alleles::Union{Nothing,Vector{Int64}} = nothing,
    idx_trait::Int64 = 1,
    GRM_type::String = [&quot;simple&quot;, &quot;ploidy-aware&quot;][1],
    standardise::Bool = true,
    verbose::Bool = false,
)::Tuple{Matrix{Float64},Vector{Float64},Matrix{Float64},Fit}</code></pre><p>Prepare the allele frequency matrix, phenotype vector, genetic relationship matrix and genotype-to-phenotype regression fit struct (G, y, GRM, fit)</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GBCore.simulategenomes(verbose=false);

julia&gt; ploidy = 4;

julia&gt; genomes.allele_frequencies = round.(genomes.allele_frequencies .* ploidy) ./ ploidy;

julia&gt; proportion_of_variance = zeros(9, 1); proportion_of_variance[1, 1] = 0.5;

julia&gt; trials, effects = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.05 0.00 0.00;], proportion_of_variance = proportion_of_variance, verbose=false);;

julia&gt; phenomes = extractphenomes(trials);

julia&gt; G, y, GRM, fit = gwasprep(genomes, phenomes);

julia&gt; sum(abs.(mean(G, dims=1)[1,:]) .&lt; 1e-10) == size(G, 2)
true

julia&gt; sum(abs.(std(G, dims=1)[1,:] .- 1) .&lt; 1e-10) == size(G, 2)
true

julia&gt; (abs(mean(y)) &lt; 1e-10, abs(std(y) - 1) &lt; 1e-10)
(true, true)

julia&gt; size(G, 1) == length(y)
true

julia&gt; (size(G, 1), length(y)) == size(GRM)
true

julia&gt; length(fit.entries) == length(y)
true

julia&gt; length(fit.b_hat) == size(G, 2)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/0d7695b86e4b451d4d07d075757f006e48cf6ca2/src/gwas.jl#L1-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.gwasreml-Tuple{GBCore.Genomes, GBCore.Phenomes}" href="#GBModels.gwasreml-Tuple{GBCore.Genomes, GBCore.Phenomes}"><code>GBModels.gwasreml</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gwasreml(
    genomes::Genomes,
    phenomes::Phenomes;
    idx_entries::Union{Nothing,Vector{Int64}} = nothing,
    idx_loci_alleles::Union{Nothing,Vector{Int64}} = nothing,
    idx_trait::Int64 = 1,
    GRM_type::String = [&quot;simple&quot;, &quot;ploidy-aware&quot;][1],
    verbose::Bool = false,
)::Fit</code></pre><p>Genome-association analysis via restricted likelihood estimation, where the genetic relationship matrix multiplied by σ²_g is the covariance matrix of the genotype effects.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GBCore.simulategenomes(l=1_000, verbose=false);

julia&gt; ploidy = 4;

julia&gt; genomes.allele_frequencies = round.(genomes.allele_frequencies .* ploidy) ./ ploidy;

julia&gt; proportion_of_variance = zeros(9, 1); proportion_of_variance[1, 1] = 0.5;

julia&gt; trials, effects = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.05 0.00 0.00;], proportion_of_variance = proportion_of_variance, verbose=false);;

julia&gt; phenomes = extractphenomes(trials);

julia&gt; fit_1 = gwasreml(genomes, phenomes, GRM_type=&quot;simple&quot;);

julia&gt; fit_1.model
&quot;GWAS_REML&quot;

julia&gt; fit_2 = gwasreml(genomes, phenomes, GRM_type=&quot;ploidy-aware&quot;);

julia&gt; fit_2.model
&quot;GWAS_REML&quot;

julia&gt; findall(fit_1.b_hat .== maximum(fit_1.b_hat)) == findall(fit_2.b_hat .== maximum(fit_2.b_hat))
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/0d7695b86e4b451d4d07d075757f006e48cf6ca2/src/gwas.jl#L403-L444">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.invoneplus-Tuple{Any}" href="#GBModels.invoneplus-Tuple{Any}"><code>GBModels.invoneplus</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">invoneplus(x) = sqrt(abs(x))</code></pre><p>An endofunction within the zero to one domain which accepts a single input and takes the inverse of one plus the input.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/0d7695b86e4b451d4d07d075757f006e48cf6ca2/src/transformation.jl#L9-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.lasso-Tuple{}" href="#GBModels.lasso-Tuple{}"><code>GBModels.lasso</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lasso(;
    genomes::Genomes,
    phenomes::Phenomes,
    idx_entries::Union{Nothing,Vector{Int64}} = nothing,
    idx_loci_alleles::Union{Nothing,Vector{Int64}} = nothing,
    idx_trait::Int64 = 1,
    verbose::Bool = false,
)::Fit</code></pre><p>Fit a LASSO (least absolute shrinkage and selection operator; L1) regression model</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GBCore.simulategenomes(verbose=false);

julia&gt; trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);;

julia&gt; phenomes = extractphenomes(trials);

julia&gt; fit = lasso(genomes=genomes, phenomes=phenomes);

julia&gt; fit.model == &quot;lasso&quot;
true

julia&gt; fit.metrics[&quot;cor&quot;] &gt; 0.50
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/0d7695b86e4b451d4d07d075757f006e48cf6ca2/src/linear.jl#L190-L218">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.log10epsdivlog10eps-Tuple{Any}" href="#GBModels.log10epsdivlog10eps-Tuple{Any}"><code>GBModels.log10epsdivlog10eps</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">log10epsdivlog10eps(x)</code></pre><p>An endofunction within the zero to one domain which accepts a single input and take its log10 corrected by machine epsilon to keep it in the domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/0d7695b86e4b451d4d07d075757f006e48cf6ca2/src/transformation.jl#L16-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.loglikreml-Tuple{Vector{Float64}, Tuple{Vector{Float64}, Matrix{Float64}, Matrix{Float64}}}" href="#GBModels.loglikreml-Tuple{Vector{Float64}, Tuple{Vector{Float64}, Matrix{Float64}, Matrix{Float64}}}"><code>GBModels.loglikreml</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">loglikreml(θ::Vector{Float64}, data::Tuple{Vector{Float64},Matrix{Float64},Matrix{Float64}})::Float64</code></pre><p>Restricted maximum likelihood function gor genome-wide asociation</p><p>Model:</p><pre><code class="nohighlight hljs">y = Xb + Zu + e</code></pre><p>where:</p><pre><code class="nohighlight hljs">u ~ N(0.0, σ²_u * GRM)
y ~ N(Xb, σ²_u * GRM + σ²_e * I)</code></pre><p><strong>Examples</strong></p><p>```jldoctest; setup = :(using GBCore, GBModels, LinearAlgebra, StatsBase) julia&gt; genomes = GBCore.simulategenomes(verbose=false);</p><p>julia&gt; ploidy = 4;</p><p>julia&gt; genomes.allele<em>frequencies = round.(genomes.allele</em>frequencies .* ploidy) ./ ploidy;</p><p>julia&gt; proportion<em>of</em>variance = zeros(9, 1); proportion<em>of</em>variance[1, 1] = 0.5;</p><p>julia&gt; trials, effects = GBCore.simulatetrials(genomes=genomes, n<em>years=1, n</em>seasons=1, n<em>harvests=1, n</em>sites=1, n<em>replications=1, f</em>add<em>dom</em>epi=[0.05 0.00 0.00;], proportion<em>of</em>variance = proportion<em>of</em>variance, verbose=false);;</p><p>julia&gt; phenomes = extractphenomes(trials);</p><p>julia&gt; G, y, GRM, fit = gwasprep(genomes, phenomes);</p><p>julia&gt; loglik = loglikreml([0.53, 0.15], (y, hcat(ones(length(y)), G[:, 1]), GRM));</p><p>julia&gt; loglik &lt; 100 true</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/0d7695b86e4b451d4d07d075757f006e48cf6ca2/src/gwas.jl#L329-L367">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.mult-Tuple{Any, Any}" href="#GBModels.mult-Tuple{Any, Any}"><code>GBModels.mult</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mult(x, y) = x * y</code></pre><p>An endofunction within the zero to one domain which accepts two inputs and multiplies them.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/0d7695b86e4b451d4d07d075757f006e48cf6ca2/src/transformation.jl#L23-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.ols-Tuple{}" href="#GBModels.ols-Tuple{}"><code>GBModels.ols</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ols(;
    genomes::Genomes,
    phenomes::Phenomes,
    idx_entries::Union{Nothing,Vector{Int64}} = nothing,
    idx_loci_alleles::Union{Nothing,Vector{Int64}} = nothing,
    idx_trait::Int64 = 1,
    verbose::Bool = false,
)::Fit</code></pre><p>Fit an ordinary least squares model</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GBCore.simulategenomes(verbose=false);

julia&gt; trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);;

julia&gt; phenomes = extractphenomes(trials);

julia&gt; fit = ols(genomes=genomes, phenomes=phenomes);

julia&gt; fit.model == &quot;ols&quot;
true

julia&gt; fit.metrics[&quot;cor&quot;] &gt; 0.50
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/0d7695b86e4b451d4d07d075757f006e48cf6ca2/src/linear.jl#L1-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.predict-Tuple{}" href="#GBModels.predict-Tuple{}"><code>GBModels.predict</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">predict(; fit::Fit, genomes::Genomes, idx_entries::Vector{Int64})::Vector{Float64}</code></pre><p>Predict the phenotypes given a genomic prediction model fit, a genomes and the corresponding entries indexes</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GBCore.simulategenomes(verbose=false);

julia&gt; trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);

julia&gt; phenomes = extractphenomes(trials);

julia&gt; fit = ridge(genomes=genomes, phenomes=phenomes, idx_entries=collect(1:90));

julia&gt; y_hat = GBModels.predict(fit=fit, genomes=genomes, idx_entries=collect(91:100));

julia&gt; cor(phenomes.phenotypes[91:100, 1], y_hat) &gt; 0.5
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/0d7695b86e4b451d4d07d075757f006e48cf6ca2/src/prediction.jl#L119-L139">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.raise-Tuple{Any, Any}" href="#GBModels.raise-Tuple{Any, Any}"><code>GBModels.raise</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">raise(x, y) = x^y</code></pre><p>An endofunction within the zero to one domain which accepts two inputs, and raises the first to the power of the second.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/0d7695b86e4b451d4d07d075757f006e48cf6ca2/src/transformation.jl#L37-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.reconstitutefeatures-Tuple{GBCore.Genomes}" href="#GBModels.reconstitutefeatures-Tuple{GBCore.Genomes}"><code>GBModels.reconstitutefeatures</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reconstitutefeatures(
    genomes::Genomes;
    feature_names::Vector{String},
    transformations1::Vector{Function} = [square, invoneplus, log10epsdivlog10eps],
    transformations2::Vector{Function} = [mult, addnorm, raise],
    verbose::Bool = false,
)::Genomes</code></pre><p>Reconstitute epistasis features given a genomes struct and names of the features which include the endofunction names used.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GBCore.simulategenomes(l=1_000, verbose=false);

julia&gt; trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);;

julia&gt; phenomes = extractphenomes(trials);

julia&gt; genomes_epifeat = epistasisfeatures(genomes, phenomes, n_new_features_per_transformation=50, n_reps=2, verbose=false);

julia&gt; feature_names = genomes_epifeat.loci_alleles;

julia&gt; genomes_epifeat_reconstructed = reconstitutefeatures(genomes, feature_names=feature_names);

julia&gt; genomes_epifeat == genomes_epifeat_reconstructed
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/0d7695b86e4b451d4d07d075757f006e48cf6ca2/src/transformation.jl#L579-L607">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.ridge-Tuple{}" href="#GBModels.ridge-Tuple{}"><code>GBModels.ridge</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ridge(;
    genomes::Genomes,
    phenomes::Phenomes,
    idx_entries::Union{Nothing,Vector{Int64}} = nothing,
    idx_loci_alleles::Union{Nothing,Vector{Int64}} = nothing,
    idx_trait::Int64 = 1,
    verbose::Bool = false,
)::Fit</code></pre><p>Fit a ridge (L2) regression model</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GBCore.simulategenomes(verbose=false);

julia&gt; trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);;

julia&gt; phenomes = extractphenomes(trials);

julia&gt; fit = ridge(genomes=genomes, phenomes=phenomes);

julia&gt; fit.model == &quot;ridge&quot;
true

julia&gt; fit.metrics[&quot;cor&quot;] &gt; 0.50
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/0d7695b86e4b451d4d07d075757f006e48cf6ca2/src/linear.jl#L82-L110">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.square-Tuple{Any}" href="#GBModels.square-Tuple{Any}"><code>GBModels.square</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">square(x) = x^2</code></pre><p>An endofunction within the zero to one domain which accepts a single input and squares it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/0d7695b86e4b451d4d07d075757f006e48cf6ca2/src/transformation.jl#L2-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.transform1-Tuple{Function, GBCore.Genomes, GBCore.Phenomes}" href="#GBModels.transform1-Tuple{Function, GBCore.Genomes, GBCore.Phenomes}"><code>GBModels.transform1</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">transform1(
    f::Function,
    genomes::Genomes,
    phenomes::Phenomes;
    idx_trait::Int64 = 1,
    idx_entries::Union{Nothing,Vector{Int64}} = nothing,
    idx_loci_alleles::Union{Nothing,Vector{Int64}} = nothing,
    n_new_features_per_transformation::Int64 = 1_000,
    ϵ::Float64 = eps(Float64),
    use_abs::Bool = false,
    σ²_threshold::Float64 = 0.01,
    verbose::Bool = false,
)::Genomes</code></pre><p>Apply a function to each allele frequency in genomes. Please Use named functions if you wish to reconstruct the transformation from the <code>loci_alleles</code> field.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GBCore.simulategenomes(l=1_000, verbose=false);

julia&gt; trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);;

julia&gt; phenomes = extractphenomes(trials);

julia&gt; genomes_transformed = transform1(x -&gt; x^2, genomes, phenomes);

julia&gt; idx = findall(genomes.loci_alleles .== split(split(replace(genomes_transformed.loci_alleles[1], &quot;)&quot; =&gt; &quot;&quot;), &quot;(&quot;)[2], &quot;,&quot;)[1])[1];

julia&gt; mean(sqrt.(genomes_transformed.allele_frequencies[:, 1]) .- genomes.allele_frequencies[:, idx]) &lt; 1e-10
true

julia&gt; squareaddpi(x) = x^2 + pi;

julia&gt; genomes_transformed = transform1(squareaddpi, genomes, phenomes);

julia&gt; idx = findall(genomes.loci_alleles .== split(split(replace(genomes_transformed.loci_alleles[1], &quot;)&quot; =&gt; &quot;&quot;), &quot;(&quot;)[2], &quot;,&quot;)[1])[1];

julia&gt; mean(squareaddpi.(genomes.allele_frequencies[:, idx]) .- genomes_transformed.allele_frequencies[:, 1]) &lt; 1e-10
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/0d7695b86e4b451d4d07d075757f006e48cf6ca2/src/transformation.jl#L44-L86">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.transform2-Tuple{Function, GBCore.Genomes, GBCore.Phenomes}" href="#GBModels.transform2-Tuple{Function, GBCore.Genomes, GBCore.Phenomes}"><code>GBModels.transform2</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">transform2(
    f::Function,
    genomes::Genomes,
    phenomes::Phenomes;
    idx_trait::Int64 = 1,
    idx_entries::Union{Nothing,Vector{Int64}} = nothing,
    idx_loci_alleles::Union{Nothing,Vector{Int64}} = nothing,
    n_new_features_per_transformation::Int64 = 1_000,
    ϵ::Float64 = eps(Float64),
    use_abs::Bool = false,
    σ²_threshold::Float64 = 0.01,
    commutative::Bool = false,
    verbose::Bool = false,
)::Genomes</code></pre><p>Apply a function to pairs of allele frequency in genomes. Please Use named functions if you wish to reconstruct the transformation from the <code>loci_alleles</code> field.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GBCore.simulategenomes(l=1_000, verbose=false);

julia&gt; trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);;

julia&gt; phenomes = extractphenomes(trials);

julia&gt; genomes_transformed = transform2((x,y) -&gt; (x^2 + sqrt(y)) / 2, genomes, phenomes);

julia&gt; idx_1 = findall(genomes.loci_alleles .== split(split(replace(genomes_transformed.loci_alleles[1], &quot;)&quot; =&gt; &quot;&quot;), &quot;(&quot;)[2], &quot;,&quot;)[1])[1];

julia&gt; idx_2 = findall(genomes.loci_alleles .== split(split(replace(genomes_transformed.loci_alleles[1], &quot;)&quot; =&gt; &quot;&quot;), &quot;(&quot;)[2], &quot;,&quot;)[2])[1];

julia&gt; mean((genomes.allele_frequencies[:,idx_1].^2 .+ sqrt.(genomes.allele_frequencies[:,idx_2])) ./ 2 .- genomes_transformed.allele_frequencies[:,1]) &lt; 1e-10
true

julia&gt; raisexbyythenlog(x, y) = log(abs(x^y));

julia&gt; genomes_transformed = transform2(raisexbyythenlog, genomes, phenomes);

julia&gt; idx_1 = findall(genomes.loci_alleles .== split(split(replace(genomes_transformed.loci_alleles[1], &quot;)&quot; =&gt; &quot;&quot;), &quot;(&quot;)[2], &quot;,&quot;)[1])[1];

julia&gt; idx_2 = findall(genomes.loci_alleles .== split(split(replace(genomes_transformed.loci_alleles[1], &quot;)&quot; =&gt; &quot;&quot;), &quot;(&quot;)[2], &quot;,&quot;)[2])[1];

julia&gt; mean(raisexbyythenlog.(genomes.allele_frequencies[:,idx_1], genomes.allele_frequencies[:,idx_2]) .- genomes_transformed.allele_frequencies[:,1]) &lt; 1e-10
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/0d7695b86e4b451d4d07d075757f006e48cf6ca2/src/transformation.jl#L198-L245">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.turing_bayesG-Tuple{Any, Any}" href="#GBModels.turing_bayesG-Tuple{Any, Any}"><code>GBModels.turing_bayesG</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Turing specification of Bayesian linear regression using a Gaussian prior with common variance</p><p><strong>Example usage</strong></p><pre><code class="language-julia hljs"># Benchmarking
genomes = GBCore.simulategenomes(n=10, l=100)
trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.9 0.01 0.00;])
phenomes = extractphenomes(trials)
G::Matrix{Float64} = genomes.allele_frequencies
y::Vector{Float64} = phenomes.phenotypes[:, 1]
model = turing_bayesG(G, y)
benchmarks = TuringBenchmarking.benchmark_model(
    model;
    # Check correctness of computations
    check=true,
    # Automatic differentiation backends to check and benchmark
    adbackends=[:forwarddiff, :reversediff, :reversediff_compiled, :zygote]
)


# Test more loci
genomes = GBCore.simulategenomes(n=10, l=10_000)
trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.9 0.01 0.00;])
phenomes = extractphenomes(trials)
G::Matrix{Float64} = genomes.allele_frequencies
y::Vector{Float64} = phenomes.phenotypes[:, 1]
# Check for uninferred types in the model
@code_warntype model = turing_bayesG(G, y)
# Fit
model = turing_bayesG(G, y)
# We use compile=true in AutoReverseDiff() because we do not have any if-statements in our Turing model below
rng::TaskLocalRNG = Random.seed!(123)
niter::Int64 = 1_500
nburnin::Int64 = 500
@time chain = Turing.sample(rng, model, NUTS(nburnin, 0.65, max_depth=5, Δ_max=1000.0, init_ϵ=0.2; adtype=AutoReverseDiff(compile=true)), niter-nburnin, progress=true);
# @time chain = Turing.sample(rng, model, HMC(0.05, 10; adtype=AutoReverseDiff(compile=true)), niter, progress=true);
p = Plots.histogram(chain[:σ²])
Plots.gui(p)
# Use the mean paramter values after 150 burn-in iterations
params = Turing.get_params(chain[501:end, :, :]);
b_hat = vcat(mean(params.intercept), mean(stack(params.coefficients, dims=1)[:, :, 1], dims=2)[:,1]);
# Assess prediction accuracy
y_pred::Vector{Float64} = hcat(ones(size(G,1)), G) * b_hat;
UnicodePlots.scatterplot(y, y_pred)
performance::Dict{String, Float64} = metrics(y, y_pred)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/0d7695b86e4b451d4d07d075757f006e48cf6ca2/src/bayes.jl#L175-L222">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.turing_bayesG_logit-Tuple{Any, Any}" href="#GBModels.turing_bayesG_logit-Tuple{Any, Any}"><code>GBModels.turing_bayesG_logit</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Turing specification of Bayesian logistic regression using a Gaussian prior with common variance</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/0d7695b86e4b451d4d07d075757f006e48cf6ca2/src/bayes.jl#L803-L805">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.turing_bayesGs-Tuple{Any, Any}" href="#GBModels.turing_bayesGs-Tuple{Any, Any}"><code>GBModels.turing_bayesGs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Turing specification of Bayesian linear regression using a Gaussian prior with varying variances</p><p><strong>Example usage</strong></p><pre><code class="language-julia hljs"># Simulate data
genomes = GBCore.simulategenomes(n=10, l=100)
trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.9 0.01 0.00;])
phenomes = extractphenomes(trials)
# Extract genotype and phenotype data
G::Matrix{Float64} = genomes.allele_frequencies
y::Vector{Float64} = phenomes.phenotypes[:, 1]
# Regress for just 200 iterations for demonstration purposes only. Use way way more iterations, e.g. 10,000.
model = turing_bayesGs(G, y)
# We use compile=true in AutoReverseDiff() because we do not have any if-statements in our Turing model below
rng::TaskLocalRNG = Random.seed!(123)
niter::Int64 = 1_500
nburnin::Int64 = 500
@time chain = Turing.sample(rng, model, NUTS(nburnin, 0.5, max_depth=5, Δ_max=1000.0, init_ϵ=0.2; adtype=AutoReverseDiff(compile=true)), niter-nburnin, progress=true);
# Use the mean paramter values after 150 burn-in iterations
params = Turing.get_params(chain[150:end, :, :]);
b_hat = vcat(mean(params.intercept), mean(stack(params.coefficients, dims=1)[:, :, 1], dims=2)[:,1]);
# Assess prediction accuracy
y_pred::Vector{Float64} = hcat(ones(size(G,1)), G) * b_hat;
UnicodePlots.scatterplot(y, y_pred)
performance::Dict{String, Float64} = metrics(y, y_pred)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/0d7695b86e4b451d4d07d075757f006e48cf6ca2/src/bayes.jl#L239-L266">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.turing_bayesGπ-Tuple{Any, Any}" href="#GBModels.turing_bayesGπ-Tuple{Any, Any}"><code>GBModels.turing_bayesGπ</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Turing specification of Bayesian linear regression using a Gaussian prior with a point mass at zero and common variance</p><p><strong>Example usage</strong></p><pre><code class="language-julia hljs"># Simulate data
genomes = GBCore.simulategenomes(n=10, l=100)
trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.9 0.01 0.00;])
phenomes = extractphenomes(trials)
# Extract genotype and phenotype data
G::Matrix{Float64} = genomes.allele_frequencies
y::Vector{Float64} = phenomes.phenotypes[:, 1]
# Regress for just 200 iterations for demonstration purposes only. Use way way more iterations, e.g. 10,000.
model = turing_bayesGπ(G, y)
# We use compile=true in AutoReverseDiff() because we do not have any if-statements in our Turing model below
rng::TaskLocalRNG = Random.seed!(123)
niter::Int64 = 1_500
nburnin::Int64 = 500
@time chain = Turing.sample(rng, model, NUTS(nburnin, 0.5, max_depth=5, Δ_max=1000.0, init_ϵ=0.2; adtype=AutoReverseDiff(compile=true)), niter-nburnin, progress=true);
# Use the mean paramter values after 150 burn-in iterations
params = Turing.get_params(chain[150:end, :, :]);
b_hat = vcat(mean(params.intercept), mean(stack(params.coefficients, dims=1)[:, :, 1], dims=2)[:,1]);
# Assess prediction accuracy
y_pred::Vector{Float64} = hcat(ones(size(G,1)), G) * b_hat;
UnicodePlots.scatterplot(y, y_pred)
performance::Dict{String, Float64} = metrics(y, y_pred)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/0d7695b86e4b451d4d07d075757f006e48cf6ca2/src/bayes.jl#L339-L366">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.turing_bayesGπs-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, DynamicPPL.TypeWrap{T}}} where T" href="#GBModels.turing_bayesGπs-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, DynamicPPL.TypeWrap{T}}} where T"><code>GBModels.turing_bayesGπs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Turing specification of Bayesian linear regression using a Gaussian prior with a point mass at zero and varying variances</p><p><strong>Example usage</strong></p><pre><code class="language-julia hljs"># Simulate data
genomes = GBCore.simulategenomes(n=10, l=100)
trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.9 0.01 0.00;])
phenomes = extractphenomes(trials)
# Extract genotype and phenotype data
G::Matrix{Float64} = genomes.allele_frequencies
y::Vector{Float64} = phenomes.phenotypes[:, 1]
# Regress for just 200 iterations for demonstration purposes only. Use way way more iterations, e.g. 10,000.
model = turing_bayesGπs(G, y)
# We use compile=true in AutoReverseDiff() because we do not have any if-statements in our Turing model below
rng::TaskLocalRNG = Random.seed!(123)
niter::Int64 = 1_500
nburnin::Int64 = 500
@time chain = Turing.sample(rng, model, NUTS(nburnin, 0.5, max_depth=5, Δ_max=1000.0, init_ϵ=0.2; adtype=AutoReverseDiff(compile=true)), niter-nburnin, progress=true);
# Use the mean paramter values after 150 burn-in iterations
params = Turing.get_params(chain[150:end, :, :]);
b_hat = vcat(mean(params.intercept), mean(stack(params.coefficients, dims=1)[:, :, 1], dims=2)[:,1]);
# Assess prediction accuracy
y_pred::Vector{Float64} = hcat(ones(size(G,1)), G) * b_hat;
UnicodePlots.scatterplot(y, y_pred)
performance::Dict{String, Float64} = metrics(y, y_pred)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/0d7695b86e4b451d4d07d075757f006e48cf6ca2/src/bayes.jl#L381-L408">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.turing_bayesL-Tuple{Any, Any}" href="#GBModels.turing_bayesL-Tuple{Any, Any}"><code>GBModels.turing_bayesL</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Turing specification of Bayesian linear regression using a Laplacian prior with a common scale</p><p><strong>Example usage</strong></p><pre><code class="language-julia hljs"># Simulate data
genomes = GBCore.simulategenomes(n=10, l=100)
trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.9 0.01 0.00;])
phenomes = extractphenomes(trials)
# Extract genotype and phenotype data
G::Matrix{Float64} = genomes.allele_frequencies
y::Vector{Float64} = phenomes.phenotypes[:, 1]
# Regress for just 200 iterations for demonstration purposes only. Use way way more iterations, e.g. 10,000.
model = turing_bayesL(G, y)
# We use compile=true in AutoReverseDiff() because we do not have any if-statements in our Turing model below
rng::TaskLocalRNG = Random.seed!(123)
niter::Int64 = 1_500
nburnin::Int64 = 500
@time chain = Turing.sample(rng, model, NUTS(nburnin, 0.5, max_depth=5, Δ_max=1000.0, init_ϵ=0.2; adtype=AutoReverseDiff(compile=true)), niter-nburnin, progress=true);
# Use the mean paramter values after 150 burn-in iterations
params = Turing.get_params(chain[150:end, :, :]);
b_hat = vcat(mean(params.intercept), mean(stack(params.coefficients, dims=1)[:, :, 1], dims=2)[:,1]);
# Assess prediction accuracy
y_pred::Vector{Float64} = hcat(ones(size(G,1)), G) * b_hat;
UnicodePlots.scatterplot(y, y_pred)
performance::Dict{String, Float64} = metrics(y, y_pred)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/0d7695b86e4b451d4d07d075757f006e48cf6ca2/src/bayes.jl#L427-L454">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.turing_bayesLs-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, DynamicPPL.TypeWrap{T}}} where T" href="#GBModels.turing_bayesLs-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, DynamicPPL.TypeWrap{T}}} where T"><code>GBModels.turing_bayesLs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Turing specification of Bayesian linear regression using a Laplacian prior with varying scales</p><p><strong>Example usage</strong></p><pre><code class="language-julia hljs"># Simulate data
genomes = GBCore.simulategenomes(n=10, l=100)
trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.9 0.01 0.00;])
phenomes = extractphenomes(trials)
# Extract genotype and phenotype data
G::Matrix{Float64} = genomes.allele_frequencies
y::Vector{Float64} = phenomes.phenotypes[:, 1]
# Regress for just 200 iterations for demonstration purposes only. Use way way more iterations, e.g. 10,000.
model = turing_bayesLs(G, y)
# We use compile=true in AutoReverseDiff() because we do not have any if-statements in our Turing model below
rng::TaskLocalRNG = Random.seed!(123)
niter::Int64 = 1_500
nburnin::Int64 = 500
@time chain = Turing.sample(rng, model, NUTS(nburnin, 0.5, max_depth=5, Δ_max=1000.0, init_ϵ=0.2; adtype=AutoReverseDiff(compile=true)), niter-nburnin, progress=true);
# Use the mean paramter values after 150 burn-in iterations
params = Turing.get_params(chain[150:end, :, :]);
b_hat = vcat(mean(params.intercept), mean(stack(params.coefficients, dims=1)[:, :, 1], dims=2)[:,1]);
# Assess prediction accuracy
y_pred::Vector{Float64} = hcat(ones(size(G,1)), G) * b_hat;
UnicodePlots.scatterplot(y, y_pred)
performance::Dict{String, Float64} = metrics(y, y_pred)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/0d7695b86e4b451d4d07d075757f006e48cf6ca2/src/bayes.jl#L469-L496">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.turing_bayesLπ-Tuple{Any, Any}" href="#GBModels.turing_bayesLπ-Tuple{Any, Any}"><code>GBModels.turing_bayesLπ</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Turing specification of Bayesian linear regression using a Laplacian prior with a point mass at zero and common scale</p><p><strong>Example usage</strong></p><pre><code class="language-julia hljs"># Simulate data
genomes = GBCore.simulategenomes(n=10, l=100)
trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.9 0.01 0.00;])
phenomes = extractphenomes(trials)
# Extract genotype and phenotype data
G::Matrix{Float64} = genomes.allele_frequencies
y::Vector{Float64} = phenomes.phenotypes[:, 1]
# Regress for just 200 iterations for demonstration purposes only. Use way way more iterations, e.g. 10,000.
model = turing_bayesLπ(G, y)
# We use compile=true in AutoReverseDiff() because we do not have any if-statements in our Turing model below
rng::TaskLocalRNG = Random.seed!(123)
niter::Int64 = 1_500
nburnin::Int64 = 500
@time chain = Turing.sample(rng, model, NUTS(nburnin, 0.5, max_depth=5, Δ_max=1000.0, init_ϵ=0.2; adtype=AutoReverseDiff(compile=true)), niter-nburnin, progress=true);
# Use the mean paramter values after 150 burn-in iterations
params = Turing.get_params(chain[150:end, :, :]);
b_hat = vcat(mean(params.intercept), mean(stack(params.coefficients, dims=1)[:, :, 1], dims=2)[:,1]);
# Assess prediction accuracy
y_pred::Vector{Float64} = hcat(ones(size(G,1)), G) * b_hat;
UnicodePlots.scatterplot(y, y_pred)
performance::Dict{String, Float64} = metrics(y, y_pred)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/0d7695b86e4b451d4d07d075757f006e48cf6ca2/src/bayes.jl#L572-L599">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.turing_bayesLπs-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, DynamicPPL.TypeWrap{T}}} where T" href="#GBModels.turing_bayesLπs-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, DynamicPPL.TypeWrap{T}}} where T"><code>GBModels.turing_bayesLπs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Turing specification of Bayesian linear regression using a Laplacian prior with a point mass at zero and common scale</p><p><strong>Example usage</strong></p><pre><code class="language-julia hljs"># Simulate data
genomes = GBCore.simulategenomes(n=10, l=100)
trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.9 0.01 0.00;])
phenomes = extractphenomes(trials)
# Extract genotype and phenotype data
G::Matrix{Float64} = genomes.allele_frequencies
y::Vector{Float64} = phenomes.phenotypes[:, 1]
# Regress for just 200 iterations for demonstration purposes only. Use way way more iterations, e.g. 10,000.
model = turing_bayesLπs(G, y)
# We use compile=true in AutoReverseDiff() because we do not have any if-statements in our Turing model below
rng::TaskLocalRNG = Random.seed!(123)
niter::Int64 = 1_500
nburnin::Int64 = 500
@time chain = Turing.sample(rng, model, NUTS(nburnin, 0.5, max_depth=5, Δ_max=1000.0, init_ϵ=0.2; adtype=AutoReverseDiff(compile=true)), niter-nburnin, progress=true);
# Use the mean paramter values after 150 burn-in iterations
params = Turing.get_params(chain[150:end, :, :]);
b_hat = vcat(mean(params.intercept), mean(stack(params.coefficients, dims=1)[:, :, 1], dims=2)[:,1]);
# Assess prediction accuracy
y_pred::Vector{Float64} = hcat(ones(size(G,1)), G) * b_hat;
UnicodePlots.scatterplot(y, y_pred)
performance::Dict{String, Float64} = metrics(y, y_pred)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/0d7695b86e4b451d4d07d075757f006e48cf6ca2/src/bayes.jl#L614-L641">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.turing_bayesT-Tuple{Any, Any}" href="#GBModels.turing_bayesT-Tuple{Any, Any}"><code>GBModels.turing_bayesT</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Turing specification of Bayesian linear regression using a T-distribution</p><p><strong>Example usage</strong></p><pre><code class="language-julia hljs"># Simulate data
genomes = GBCore.simulategenomes(n=10, l=100)
trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.9 0.01 0.00;])
phenomes = extractphenomes(trials)
# Extract genotype and phenotype data
G::Matrix{Float64} = genomes.allele_frequencies
y::Vector{Float64} = phenomes.phenotypes[:, 1]
# Regress for just 200 iterations for demonstration purposes only. Use way way more iterations, e.g. 10,000.
model = turing_bayesT(G, y)
# We use compile=true in AutoReverseDiff() because we do not have any if-statements in our Turing model below
rng::TaskLocalRNG = Random.seed!(123)
niter::Int64 = 1_500
nburnin::Int64 = 500
@time chain = Turing.sample(rng, model, NUTS(nburnin, 0.5, max_depth=5, Δ_max=1000.0, init_ϵ=0.2; adtype=AutoReverseDiff(compile=true)), niter-nburnin, progress=true);
# Use the mean paramter values after 150 burn-in iterations
params = Turing.get_params(chain[150:end, :, :]);
b_hat = vcat(mean(params.intercept), mean(stack(params.coefficients, dims=1)[:, :, 1], dims=2)[:,1]);
# Assess prediction accuracy
y_pred::Vector{Float64} = hcat(ones(size(G,1)), G) * b_hat;
UnicodePlots.scatterplot(y, y_pred)
performance::Dict{String, Float64} = metrics(y, y_pred)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/0d7695b86e4b451d4d07d075757f006e48cf6ca2/src/bayes.jl#L662-L689">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.turing_bayesTπ-Tuple{Any, Any}" href="#GBModels.turing_bayesTπ-Tuple{Any, Any}"><code>GBModels.turing_bayesTπ</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Turing specification of Bayesian linear regression using a T-distribution with a point mass at zero</p><p><strong>Example usage</strong></p><pre><code class="language-julia hljs"># Simulate data
genomes = GBCore.simulategenomes(n=10, l=100)
trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.9 0.01 0.00;])
phenomes = extractphenomes(trials)
# Extract genotype and phenotype data
G::Matrix{Float64} = genomes.allele_frequencies
y::Vector{Float64} = phenomes.phenotypes[:, 1]
# Regress for just 200 iterations for demonstration purposes only. Use way way more iterations, e.g. 10,000.
model = turing_bayesTπ(G, y)
# We use compile=true in AutoReverseDiff() because we do not have any if-statements in our Turing model below
rng::TaskLocalRNG = Random.seed!(123)
niter::Int64 = 1_500
nburnin::Int64 = 500
@time chain = Turing.sample(rng, model, NUTS(nburnin, 0.5, max_depth=5, Δ_max=1000.0, init_ϵ=0.2; adtype=AutoReverseDiff(compile=true)), niter-nburnin, progress=true);
# Use the mean paramter values after 150 burn-in iterations
params = Turing.get_params(chain[150:end, :, :]);
b_hat = vcat(mean(params.intercept), mean(stack(params.coefficients, dims=1)[:, :, 1], dims=2)[:,1]);
# Assess prediction accuracy
y_pred::Vector{Float64} = hcat(ones(size(G,1)), G) * b_hat;
UnicodePlots.scatterplot(y, y_pred)
performance::Dict{String, Float64} = metrics(y, y_pred)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/0d7695b86e4b451d4d07d075757f006e48cf6ca2/src/bayes.jl#L760-L787">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.validate-Tuple{GBCore.Fit, GBCore.Genomes, GBCore.Phenomes}" href="#GBModels.validate-Tuple{GBCore.Fit, GBCore.Genomes, GBCore.Phenomes}"><code>GBModels.validate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">validate(
    fit::Fit,
    genomes::Genomes,
    phenomes::Phenomes; 
    idx_validation::Vector{Int64},
    replication::String=&quot;&quot;,
    fold::String=&quot;&quot;
)::CV</code></pre><p>Assess the accuracy of a genomic prediction model fit on a validation set of entries</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GBCore.simulategenomes(verbose=false);

julia&gt; trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);

julia&gt; phenomes = extractphenomes(trials);

julia&gt; fit = ridge(genomes=genomes, phenomes=phenomes, idx_entries=collect(1:90));

julia&gt; cv = validate(fit, genomes, phenomes, idx_validation=collect(91:100));

julia&gt; cv.metrics[&quot;cor&quot;] &gt; 0.50
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/0d7695b86e4b451d4d07d075757f006e48cf6ca2/src/cross_validation.jl#L1-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBModels.@string2operations-Tuple{Any}" href="#GBModels.@string2operations-Tuple{Any}"><code>GBModels.@string2operations</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">string2operations(x)</code></pre><p>Macro to <code>Meta.parse</code> a string of endofunction formulae across allele frequencies.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBModels.jl/blob/0d7695b86e4b451d4d07d075757f006e48cf6ca2/src/transformation.jl#L570-L574">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Saturday 1 February 2025 04:28">Saturday 1 February 2025</span>. Using Julia version 1.11.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
