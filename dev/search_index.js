var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = GBModels","category":"page"},{"location":"#GBModels","page":"Home","title":"GBModels","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for GBModels.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [GBModels]","category":"page"},{"location":"#GBModels.LπDist","page":"Home","title":"GBModels.LπDist","text":"Laplace distribution with a point mass at 0.0\n\n\n\n\n\n","category":"type"},{"location":"#GBModels.NπDist","page":"Home","title":"GBModels.NπDist","text":"Gaussian distribution with a point mass at 0.0\n\n\n\n\n\n","category":"type"},{"location":"#GBModels.TπDist","page":"Home","title":"GBModels.TπDist","text":"T-distribution with a point mass at 0.0\n\n\n\n\n\n","category":"type"},{"location":"#Base.maximum-Tuple{GBModels.LπDist}","page":"Home","title":"Base.maximum","text":"Maximum value of the LπDist distribution\n\n\n\n\n\n","category":"method"},{"location":"#Base.maximum-Tuple{GBModels.NπDist}","page":"Home","title":"Base.maximum","text":"Maximum value of the NπDist distribution\n\n\n\n\n\n","category":"method"},{"location":"#Base.maximum-Tuple{GBModels.TπDist}","page":"Home","title":"Base.maximum","text":"Maximum value of the TπDist distribution\n\n\n\n\n\n","category":"method"},{"location":"#Base.minimum-Tuple{GBModels.LπDist}","page":"Home","title":"Base.minimum","text":"Minimum value of the LπDist distribution\n\n\n\n\n\n","category":"method"},{"location":"#Base.minimum-Tuple{GBModels.NπDist}","page":"Home","title":"Base.minimum","text":"Minimum value of the NπDist distribution\n\n\n\n\n\n","category":"method"},{"location":"#Base.minimum-Tuple{GBModels.TπDist}","page":"Home","title":"Base.minimum","text":"Minimum value of the TπDist distribution\n\n\n\n\n\n","category":"method"},{"location":"#Base.rand-Tuple{Random.AbstractRNG, GBModels.LπDist}","page":"Home","title":"Base.rand","text":"Sampling method for LπDist\n\nExamples\n\nd = LπDist(0.1, 0.0, 1.0)\nrand(d)\n\n\n\n\n\n","category":"method"},{"location":"#Base.rand-Tuple{Random.AbstractRNG, GBModels.NπDist}","page":"Home","title":"Base.rand","text":"Sampling method for NπDist\n\nExamples\n\nd = NπDist(0.1, 0.0, 1.0)\nrand(d)\n\n\n\n\n\n","category":"method"},{"location":"#Base.rand-Tuple{Random.AbstractRNG, GBModels.TπDist}","page":"Home","title":"Base.rand","text":"Sampling method for TπDist\n\nExamples\n\nd = TπDist(0.1, 1.0)\nrand(d)\n\n\n\n\n\n","category":"method"},{"location":"#Distributions.logpdf-Tuple{GBModels.LπDist, Real}","page":"Home","title":"Distributions.logpdf","text":"log(pdf) of LπDist\n\nExamples\n\nd = LπDist(0.1, 0.0, 1.0)\nlogpdf.(d, [-1.0, 0.0, 1.0])\n\n\n\n\n\n","category":"method"},{"location":"#Distributions.logpdf-Tuple{GBModels.NπDist, Real}","page":"Home","title":"Distributions.logpdf","text":"log(pdf) of NπDist\n\nExamples\n\nd = NπDist(0.1, 0.0, 1.0)\nlogpdf.(d, [-1.0, 0.0, 1.0])\n\n\n\n\n\n","category":"method"},{"location":"#Distributions.logpdf-Tuple{GBModels.TπDist, Real}","page":"Home","title":"Distributions.logpdf","text":"log(pdf) of TπDist\n\nExamples\n\nd = TπDist(0.1, 1.0)\nlogpdf.(d, [-1.0, 0.0, 1.0])\n\n\n\n\n\n","category":"method"},{"location":"#GBModels.addnorm-Tuple{Any, Any}","page":"Home","title":"GBModels.addnorm","text":"addnorm(x, y) = (x + y) / 2.0\n\nAn endofunction within the zero to one domain which accepts two inputs, and divides their sum by two.\n\n\n\n\n\n","category":"method"},{"location":"#GBModels.bayesa-Tuple{}","page":"Home","title":"GBModels.bayesa","text":"bayesa(;\n    genomes::Genomes,\n    phenomes::Phenomes,\n    idx_entries::Union{Nothing,Vector{Int64}} = nothing,\n    idx_loci_alleles::Union{Nothing,Vector{Int64}} = nothing,\n    idx_trait::Int64 = 1,\n    n_iter::Int64 = 1_500,\n    n_burnin::Int64 = 500,\n    verbose::Bool = false,\n)::Fit\n\nFit a Bayes A model via BGLR\n\nExamples\n\njulia> genomes = GBCore.simulategenomes(verbose=false);\n\njulia> trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);;\n\njulia> phenomes = extractphenomes(trials);\n\njulia> fit = bayesa(genomes=genomes, phenomes=phenomes);\n\njulia> fit.model == \"bayesa\"\ntrue\n\njulia> fit.metrics[\"cor\"] > 0.50\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GBModels.bayesb-Tuple{}","page":"Home","title":"GBModels.bayesb","text":"bayesb(;\n    genomes::Genomes,\n    phenomes::Phenomes,\n    idx_entries::Union{Nothing,Vector{Int64}} = nothing,\n    idx_loci_alleles::Union{Nothing,Vector{Int64}} = nothing,\n    idx_trait::Int64 = 1,\n    n_iter::Int64 = 1_500,\n    n_burnin::Int64 = 500,\n    verbose::Bool = false,\n)::Fit\n\nFit a Bayes A model via BGLR\n\nExamples\n\njulia> genomes = GBCore.simulategenomes(verbose=false);\n\njulia> trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);;\n\njulia> phenomes = extractphenomes(trials);\n\njulia> fit = bayesb(genomes=genomes, phenomes=phenomes);\n\njulia> fit.model == \"bayesb\"\ntrue\n\njulia> fit.metrics[\"cor\"] > 0.50\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GBModels.bayesc-Tuple{}","page":"Home","title":"GBModels.bayesc","text":"bayesc(;\n    genomes::Genomes,\n    phenomes::Phenomes,\n    idx_entries::Union{Nothing,Vector{Int64}} = nothing,\n    idx_loci_alleles::Union{Nothing,Vector{Int64}} = nothing,\n    idx_trait::Int64 = 1,\n    n_iter::Int64 = 1_500,\n    n_burnin::Int64 = 500,\n    verbose::Bool = false,\n)::Fit\n\nFit a Bayes A model via BGLR\n\nExamples\n\njulia> genomes = GBCore.simulategenomes(verbose=false);\n\njulia> trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);;\n\njulia> phenomes = extractphenomes(trials);\n\njulia> fit = bayesc(genomes=genomes, phenomes=phenomes);\n\njulia> fit.model == \"bayesc\"\ntrue\n\njulia> fit.metrics[\"cor\"] > 0.50\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GBModels.bayesian-Tuple{Function}","page":"Home","title":"GBModels.bayesian","text":"bayesian(\n    turing_model::Function;\n    X::Matrix{Float64},\n    y::Vector{Float64},\n    sampler::String = [\"NUTS\", \"HMC\", \"HMCDA\", \"MH\", \"PG\"][1],\n    sampling_method::Int64 = 1,\n    seed::Int64 = 123,\n    n_burnin::Int64 = 500,\n    n_iter::Int64 = 1_500,\n    verbose::Bool = false,\n)::Fit\n\nFit a Bayesian linear regression models via Turing.jl\n\nExamples\n\njulia> genomes = GBCore.simulategenomes(verbose=false);\n\njulia> trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);\n\njulia> phenomes = extractphenomes(trials);\n\njulia> sol = Suppressor.@suppress bayesian(turing_bayesG, genomes=genomes, phenomes=phenomes);\n\njulia> # Slow because not multivariate T-dist: sol_T = Suppressor.@suppress bayesian(turing_bayesT, genomes=genomes, phenomes=phenomes);\n\njulia> # Even slower because of an extra set of distribution to define a non-spherical variance-covariance matrix: sol_Gs = Suppressor.@suppress bayesian(turing_bayesGs, genomes=genomes, phenomes=phenomes);\n\njulia> sol_BGLR = Suppressor.@suppress bayesian(\"BayesA\", genomes=genomes, phenomes=phenomes); sol.metrics[\"cor\"] > sol_BGLR.metrics[\"cor\"]\ntrue\n\njulia> sol.metrics[\"cor\"] > 0.5\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GBModels.bayesian-Tuple{String}","page":"Home","title":"GBModels.bayesian","text":"bayesian(\n    bglr_model::String;\n    genomes::Genomes,\n    phenomes::Phenomes,\n    idx_entries::Union{Nothing,Vector{Int64}} = nothing,\n    idx_loci_alleles::Union{Nothing,Vector{Int64}} = nothing,\n    idx_trait::Int64 = 1,\n    response_type::String = [\"gaussian\", \"ordinal\"][1], \n    n_burnin::Int64 = 500,\n    n_iter::Int64 = 1_500, \n    verbose::Bool = false\n)::Fit\n\nFit Bayesian genomic prediction models using the BGLR R package.\n\nArguments\n\nbglr_model::String: Type of BGLR model to fit. Options: \"BayesA\", \"BayesB\", \"BayesC\"\ngenomes::Genomes: Genotype data in Genomes format\nphenomes::Phenomes: Phenotype data in Phenomes format\nidx_entries::Union{Nothing,Vector{Int64}}: Optional indices to subset entries \nidx_loci_alleles::Union{Nothing,Vector{Int64}}: Optional indices to subset loci/alleles\nidx_trait::Int64: Index of trait to analyze (default: 1)\nresponse_type::String: Type of response variable. Options: \"gaussian\" or \"ordinal\" (default: \"gaussian\")\nn_burnin::Int64: Number of burn-in MCMC iterations (default: 500)\nn_iter::Int64: Total number of MCMC iterations (default: 1,500)\nverbose::Bool: Whether to print progress information (default: false)\n\nReturns\n\nFit: Object containing:\nModel fit summary\nEstimated genetic effects\nPredicted values  \nModel performance metrics\nInput data details\n\nDetails\n\nThis function provides a Julia interface to the BGLR R package for Bayesian genomic prediction. It uses temporary files to interface with R and automatically cleans up afterward.\n\nExamples\n\njulia> genomes = GBCore.simulategenomes(verbose=false);\n\njulia> trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);\n\njulia> phenomes = extractphenomes(trials);\n\njulia> sol = Suppressor.@suppress bayesian(\"BayesA\", genomes=genomes, phenomes=phenomes);\n\njulia> sol.metrics[\"cor\"] > 0.5\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GBModels.bglr-Tuple{}","page":"Home","title":"GBModels.bglr","text":"bglr(; G::Matrix{Float64}, y::Vector{Float64}, model::String=\"BayesA\", \n     response_type::String=\"gaussian\", n_iter::Int64=1_500, \n     n_burnin::Int64=500, verbose::Bool=false)::Vector{Float64}\n\nPerform Bayesian genomic prediction using the BGLR (Bayesian Generalized Linear Regression) R package.\n\nArguments\n\nG::Matrix{Float64}: Marker matrix where rows represent individuals and columns represent markers\ny::Vector{Float64}: Vector of phenotypic values\nmodel::String: Bayesian model type to use. Options: \"BayesA\", \"BayesB\", or \"BayesC\". Default: \"BayesA\"\nresponse_type::String: Type of response variable. Options: \"gaussian\" or \"ordinal\". Default: \"gaussian\"\nn_iter::Int64: Number of iterations for the MCMC chain. Default: 1,500\nn_burnin::Int64: Number of burn-in iterations to discard. Default: 500\nverbose::Bool: Whether to print progress information. Default: false\n\nReturns\n\nVector{Float64}: Estimated effects including the intercept (first element) followed by marker effects\n\nDetails\n\nThis function creates temporary files to interface with R's BGLR package, runs the Bayesian analysis, and automatically cleans up temporary files afterward. The function uses the system's R installation  and requires the BGLR package to be installed in R.\n\nNotes\n\nThis is hacky. It invokes Rscript for each instance which should allow multithreading because RCall.jl currently does not allow multithreading.\n\n\n\n\n\n","category":"method"},{"location":"#GBModels.cvbulk-Tuple{}","page":"Home","title":"GBModels.cvbulk","text":"cvbulk(;\n    genomes::Genomes,\n    phenomes::Phenomes,\n    models::Vector{Function}=[ridge],\n    n_replications::Int64=5,\n    n_folds::Int64=5,\n    seed::Int64=42,\n    verbose::Bool=true\n)::Tuple{Vector{CV}, Vector{String}}\n\nPerform replicated k-fold cross-validation of genomic prediction model(s) across all available traits and entries, ignoring populations.\n\nArguments\n\ngenomes::Genomes: Object containing genomic marker data \nphenomes::Phenomes: Object containing phenotypic trait data\nmodels::Vector{Function}: Vector of genomic prediction model functions to evaluate\nn_replications::Int64: Number of times to repeat k-fold cross-validation (default: 5)\nn_folds::Int64: Number of cross-validation folds (default: 5) \nseed::Int64: Random seed for reproducibility (default: 42)\nverbose::Bool: Whether to display progress information (default: true)\n\nReturns\n\nTuple containing:\nVector of CV objects with cross-validation results\nVector of warning messages about skipped cases\n\nThreading\n\nUses multiple threads if Julia is started with threading enabled. Example startup command: julia --threads 7,1 (7 worker threads, 1 runtime thread)\n\nNotes\n\nPerforms random k-fold partitioning of entries ignoring population structure\nHandles missing/invalid phenotype values\nValidates model inputs and data dimensions\nReturns warnings for cases with insufficient data or zero variance\n\nExample\n\njulia> genomes = GBCore.simulategenomes(verbose=false); genomes.populations = StatsBase.sample(string.(\"pop_\", 1:3), length(genomes.entries), replace=true);\n\njulia> trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, verbose=false);\n\njulia> phenomes = extractphenomes(trials);\n\njulia> cvs, notes = cvbulk(genomes=genomes, phenomes=phenomes, models=[ols, ridge], n_replications=2, n_folds=2, verbose=false);\n\njulia> df_across_entries, df_per_entry = tabularise(cvs);\n\njulia> idx_across = findall((df_across_entries.trait .== \"trait_1\") .&& (df_across_entries.model .== \"ridge\") .&& (df_across_entries.replication .== \"replication_1\") .&& (df_across_entries.fold .== \"fold_1\"));\n\njulia> idx_per = findall((df_per_entry.trait .== \"trait_1\") .&& (df_per_entry.model .== \"ridge\") .&& (df_per_entry.replication .== \"replication_1\") .&& (df_per_entry.fold .== \"fold_1\"));\n\njulia> abs(df_across_entries.cor[idx_across][1] - cor(df_per_entry.y_true[idx_per], df_per_entry.y_pred[idx_per])) < 1e-10\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GBModels.cvleaveonepopulationout-Tuple{}","page":"Home","title":"GBModels.cvleaveonepopulationout","text":"cvleaveonepopulationout(;\n    genomes::Genomes,\n    phenomes::Phenomes,\n    models::Vector{Function}=[ridge],\n    n_replications::Int64=5,\n    n_folds::Int64=5,\n    seed::Int64=42,\n    verbose::Bool=true\n)::Tuple{Vector{CV}, Vector{String}}\n\nPerforms leave-one-population-out cross-validation for genomic prediction models across all available traits.\n\nArguments\n\ngenomes::Genomes: A Genomes struct containing genetic information and population assignments\nphenomes::Phenomes: A Phenomes struct containing phenotypic data for traits\nmodels::Vector{Function}: Vector of model functions to evaluate (default: [ridge])\nn_replications::Int64: Number of replications (not used in this implementation)\nn_folds::Int64: Number of folds (not used in this implementation)\nseed::Int64: Random seed (not used in this implementation)\nverbose::Bool: If true, displays progress information during execution\n\nReturns\n\nTuple{Vector{CV}, Vector{String}}: Returns a tuple containing:\nVector of CV objects with cross-validation results\nVector of warning/error messages for skipped validations\n\nDetails\n\nThe function implements a leave-one-population-out cross-validation strategy where:\n\nFor each trait and population combination:\nUses one population as validation set\nUses remaining populations as training set\nEvaluates multiple genomic prediction models\nHandles missing data and variance checks\nSupports parallel processing via Julia's multi-threading\n\nThreading\n\nTo utilize multiple threads, start Julia with: julia --threads n,1 where n is the desired number of threads for computation and 1 is reserved for the runtime.\n\nSupported Models\n\nols (Ordinary Least Squares)\nridge (Ridge Regression)\nlasso (Lasso Regression)\nbayesa (Bayes A)\nbayesb (Bayes B)\nbayesc (Bayes C)\n\nExample\n\njulia> genomes = GBCore.simulategenomes(verbose=false); genomes.populations = StatsBase.sample(string.(\"pop_\", 1:3), length(genomes.entries), replace=true);\n\njulia> trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);\n\njulia> phenomes = extractphenomes(trials);\n\njulia> cvs, notes = cvleaveonepopulationout(genomes=genomes, phenomes=phenomes, models=[ridge, bayesa], n_replications=2, n_folds=2, verbose=false);\n\njulia> df_across_entries, df_per_entry = tabularise(cvs);\n\njulia> sum([sum(split(df_across_entries.training_population[i], \";\") .== df_across_entries.validation_population[i]) for i in 1:size(df_across_entries, 1)]) == 0\ntrue\n\njulia> idx_across = findall((df_across_entries.validation_population .== \"pop_1\") .&& (df_across_entries.trait .== \"trait_1\") .&& (df_across_entries.model .== \"ridge\"));\n\njulia> idx_per = findall((df_per_entry.validation_population .== \"pop_1\") .&& (df_per_entry.trait .== \"trait_1\") .&& (df_per_entry.model .== \"ridge\"));\n\njulia> abs(df_across_entries.cor[idx_across][1] - cor(df_per_entry.y_true[idx_per], df_per_entry.y_pred[idx_per])) < 1e-10\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GBModels.cvmultithread!-Tuple{Vector{GBCore.CV}}","page":"Home","title":"GBModels.cvmultithread!","text":"cvmultithread!(cvs::Vector{CV}; genomes::Genomes, phenomes::Phenomes, models_vector, verbose::Bool = true)::Vector{CV}\n\nPerform multi-threaded genomic prediction cross-validation using specified models.\n\nArguments\n\ncvs::Vector{CV}: Vector of cross-validation objects to be processed\ngenomes::Genomes: Genomic data containing genetic information\nphenomes::Phenomes: Phenotypic data containing trait measurements\nmodels_vector: Vector of model functions to be used for prediction (e.g., [ridge, bayesa])\nverbose::Bool=true: Whether to display progress bar during computation\n\nReturns\n\nModified cvs vector with updated cross-validation results\n\nThreading\n\nRequires Julia to be started with multiple threads to utilize parallel processing. Example startup command: julia --threads 7,1 (7 worker threads, 1 runtime thread)\n\nDetails\n\nThe function performs cross-validation in parallel for each CV object using the corresponding model from the models_vector. For each fold:\n\nExtracts training and validation indices\nFits the specified model using training data\nValidates the model using validation data\nUpdates the CV object with prediction results\n\nExample\n\njulia> genomes = GBCore.simulategenomes(verbose=false);\n\njulia> trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);\n\njulia> phenomes = extractphenomes(trials);\n\njulia> idx_training = collect(1:50);\n\njulia> idx_validation_1 = collect(51:75);\n\njulia> idx_validation_2 = collect(76:100);\n\njulia> fit = Fit(n = length(idx_training), l = length(genomes.loci_alleles) + 1); fit.model = \"ridge\"; fit.trait = \"trait_1\"; \n\njulia> fit.entries = genomes.entries[idx_training]; fit.populations = genomes.populations[idx_training]; \n\njulia> fit.b_hat_labels = vcat([\"intercept\"], genomes.loci_alleles);\n\njulia> cv_1 = CV(\"replication_1\", \"fold_1\", fit, genomes.populations[idx_validation_1], genomes.entries[idx_validation_1], zeros(length(idx_validation_1)), zeros(length(idx_validation_1)), fit.metrics);\n\njulia> cv_2 = CV(\"replication_1\", \"fold_2\", fit, genomes.populations[idx_validation_2], genomes.entries[idx_validation_2], zeros(length(idx_validation_2)), zeros(length(idx_validation_2)), fit.metrics);\n\njulia> cvs = [cv_1, cv_2]; models = [ridge, ridge];\n\njulia> cvmultithread!(cvs, genomes=genomes, phenomes=phenomes, models_vector=[ridge, bayesa], verbose=false);\n\njulia> df_across_entries, df_per_entry = tabularise(cvs);\n\njulia> idx_across = findall(df_across_entries.fold .== \"fold_2\");\n\njulia> idx_per = findall(df_per_entry.fold .== \"fold_2\");\n\njulia> abs(df_across_entries.cor[idx_across][1] - cor(df_per_entry.y_true[idx_per], df_per_entry.y_pred[idx_per])) < 1e-10\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GBModels.cvpairwisepopulation-Tuple{}","page":"Home","title":"GBModels.cvpairwisepopulation","text":"cvpairwisepopulation(;\n    genomes::Genomes,\n    phenomes::Phenomes,\n    models::Vector{Function}=[ridge],\n    n_replications::Int64=5,\n    n_folds::Int64=5, \n    seed::Int64=42,\n    verbose::Bool=true\n)::Tuple{Vector{CV}, Vector{String}}\n\nPerforms pairwise cross-validation between populations for genomic prediction models.\n\nArguments\n\ngenomes::Genomes: Genomic data containing marker information\nphenomes::Phenomes: Phenotypic data containing trait measurements\nmodels::Vector{Function}: Vector of genomic prediction model functions to evaluate (default: [ridge])\nn_replications::Int64: Number of replications (unused, maintained for API consistency)\nn_folds::Int64: Number of folds (unused, maintained for API consistency)  \nseed::Int64: Random seed (unused, maintained for API consistency)\nverbose::Bool: Whether to display progress information\n\nReturns\n\nTuple{Vector{CV}, Vector{String}}: \nVector of CV objects containing cross-validation results\nVector of warning messages for skipped validations\n\nDetails\n\nFor each pair of populations (pop1, pop2):\n\nUses pop1 as training set and pop2 as validation set\nSkips within-population validation (pop1==pop2)\nEvaluates each model on all available traits\nHandles missing/invalid phenotype values\nValidates model inputs and data dimensions\n\nThreading\n\nRequires Julia to be started with multiple threads: julia --threads n,1 where n is number of worker threads\n\nExamples\n\njulia> genomes = GBCore.simulategenomes(verbose=false); genomes.populations = StatsBase.sample(string.(\"pop_\", 1:3), length(genomes.entries), replace=true);\n\njulia> trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);\n\njulia> phenomes = extractphenomes(trials);\n\njulia> cvs, notes = cvpairwisepopulation(genomes=genomes, phenomes=phenomes, models=[ols, ridge], n_replications=2, n_folds=2, verbose=false);\n\njulia> df_across_entries, df_per_entry = tabularise(cvs);\n\njulia> sum(df_across_entries.training_population .!= df_across_entries.validation_population) == size(df_across_entries, 1)\ntrue\n\njulia> idx_across = findall((df_across_entries.training_population .== \"pop_1\") .&& (df_across_entries.validation_population .== \"pop_2\") .&& (df_across_entries.trait .== \"trait_1\") .&& (df_across_entries.model .== \"ridge\"));\n\njulia> idx_per = findall((df_per_entry.training_population .== \"pop_1\") .&& (df_per_entry.validation_population .== \"pop_2\") .&& (df_per_entry.trait .== \"trait_1\") .&& (df_per_entry.model .== \"ridge\"));\n\njulia> abs(df_across_entries.cor[idx_across][1] - cor(df_per_entry.y_true[idx_per], df_per_entry.y_pred[idx_per])) < 1e-10\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GBModels.cvperpopulation-Tuple{}","page":"Home","title":"GBModels.cvperpopulation","text":"cvperpopulation(;\n    genomes::Genomes,\n    phenomes::Phenomes,\n    models::Vector{Function}=[ridge],\n    n_replications::Int64=5,\n    n_folds::Int64=5,\n    seed::Int64=42,\n    verbose::Bool=true\n)::Tuple{Vector{CV}, Vector{String}}\n\nPerforms within-population replicated cross-validation of genomic prediction models across all available traits.\n\nArguments\n\ngenomes::Genomes: A Genomes struct containing genetic information and population assignments\nphenomes::Phenomes: A Phenomes struct containing phenotypic data for traits\nmodels::Vector{Function}=[ridge]: Vector of genomic prediction model functions to evaluate\nn_replications::Int64=5: Number of replications for cross-validation\nn_folds::Int64=5: Number of folds for k-fold cross-validation\nseed::Int64=42: Random seed for reproducibility\nverbose::Bool=true: Whether to print progress information\n\nReturns\n\nTuple{Vector{CV}, Vector{String}}: A tuple containing:\nVector of CV objects with cross-validation results\nVector of notes/warnings generated during the process\n\nDetails\n\nThe function performs separate cross-validations for each unique population in the dataset. Supports multiple genomic prediction models including:\n\nols: Ordinary Least Squares\nridge: Ridge Regression\nlasso: Lasso Regression\nbayesa: Bayes A\nbayesb: Bayes B\nbayesc: Bayes C\n\nThreading\n\nTo use multiple threads, invoke Julia with: julia --threads n,1 where n is the desired number of threads for multi-threaded processes and 1 is reserved for the Julia runtime.\n\nExamples\n\njulia> genomes = GBCore.simulategenomes(l=1_000, verbose=false); genomes.populations = StatsBase.sample(string.(\"pop_\", 1:3), length(genomes.entries), replace=true);\n\njulia> trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);\n\njulia> phenomes = extractphenomes(trials);\n\njulia> cvs, notes = cvperpopulation(genomes=genomes, phenomes=phenomes, models=[ridge, bayesa], n_replications=2, n_folds=2, verbose=false);\n\njulia> df_across_entries, df_per_entry = tabularise(cvs);\n\njulia> sort(unique(df_across_entries.training_population))\n3-element Vector{String}:\n \"pop_1\"\n \"pop_2\"\n \"pop_3\"\n\njulia> df_across_entries.training_population == df_across_entries.validation_population\ntrue\n\njulia> idx_across = findall((df_across_entries.validation_population .== \"pop_1\") .&& (df_across_entries.trait .== \"trait_1\") .&& (df_across_entries.model .== \"bayesa\") .&& (df_across_entries.replication .== \"replication_1\") .&& (df_across_entries.fold .== \"fold_1\"));\n\njulia> idx_per = findall((df_per_entry.validation_population .== \"pop_1\") .&& (df_per_entry.trait .== \"trait_1\") .&& (df_per_entry.model .== \"bayesa\") .&& (df_per_entry.replication .== \"replication_1\") .&& (df_per_entry.fold .== \"fold_1\"));\n\njulia> abs(df_across_entries.cor[idx_across][1] - cor(df_per_entry.y_true[idx_per], df_per_entry.y_pred[idx_per])) < 1e-10\ntrue\n\njulia> summary_across, summary_per_entry = summarise(cvs);\n\njulia> size(summary_across)\n(6, 8)\n\njulia> size(summary_per_entry)\n(200, 8)\n\n\n\n\n\n","category":"method"},{"location":"#GBModels.epistasisfeatures-Tuple{GBCore.Genomes, GBCore.Phenomes}","page":"Home","title":"GBModels.epistasisfeatures","text":"epistasisfeatures(\n    genomes::Genomes,\n    phenomes::Phenomes;\n    idx_trait::Int64 = 1,\n    idx_entries::Union{Nothing,Vector{Int64}} = nothing,\n    idx_loci_alleles::Union{Nothing,Vector{Int64}} = nothing,\n    transformations1::Vector{Function} = [square, invoneplus, log10epsdivlog10eps],\n    transformations2::Vector{Function} = [mult, addnorm, raise],\n    n_new_features_per_transformation::Int64 = 1_000,\n    n_reps::Int64 = 3,\n    verbose::Bool = false,\n)::Genomes\n\nGenerate epistasis features.\n\nExample\n\njulia> genomes = GBCore.simulategenomes(l=1_000, verbose=false);\n\njulia> trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);;\n\njulia> phenomes = extractphenomes(trials);\n\njulia> genomes_plus_features = epistasisfeatures(genomes, phenomes, n_new_features_per_transformation=50, n_reps=2, verbose=false);\n\njulia> cvs, notes = cvbulk(genomes=genomes_plus_features, phenomes=phenomes, models=[ridge, lasso, bayesa], verbose=false);\n\njulia> cvs_no_epi, notes_no_epi = cvbulk(genomes=genomes, phenomes=phenomes, models=[ridge, lasso, bayesa], verbose=false);\n\njulia> df_across, df_per_entry = GBCore.tabularise(cvs);\n\njulia> df_across_no_epi, df_per_entry_no_epi = GBCore.tabularise(cvs_no_epi);\n\njulia> df_summary = combine(groupby(df_across, [:trait, :model]), [[:cor] => mean, [:cor] => std]);\n\njulia> df_summary_no_epi = combine(groupby(df_across_no_epi, [:trait, :model]), [[:cor] => mean, [:cor] => std]);\n\njulia> mean(df_summary.cor_mean) > mean(df_summary_no_epi.cor_mean)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GBModels.extractxyetc-Tuple{GBCore.Genomes, GBCore.Phenomes}","page":"Home","title":"GBModels.extractxyetc","text":"extractxyetc(\n    genomes::Genomes,\n    phenomes::Phenomes;\n    idx_entries::Union{Nothing,Vector{Int64}} = nothing,\n    idx_loci_alleles::Union{Nothing,Vector{Int64}} = nothing,\n    idx_trait::Int64 = 1,\n    add_intercept::Bool = true,\n)::Tuple{Matrix{Float64},Vector{Float64},Vector{String},Vector{String},Vector{String}}\n\nExtract explanatory X matrix, response y vector, names of the entries, populations and loci-alleles from genomes and phenomes.\n\nExamples\n\njulia> genomes = GBCore.simulategenomes(verbose=false);\n\njulia> trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);;\n\njulia> phenomes = extractphenomes(trials);\n\njulia> X, y, loci_alleles = extractxyetc(genomes, phenomes);\n\njulia> X == hcat(ones(length(phenomes.entries)), genomes.allele_frequencies)\ntrue\n\njulia> y == phenomes.phenotypes[:, 1]\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GBModels.grmploidyaware-Tuple{GBCore.Genomes}","page":"Home","title":"GBModels.grmploidyaware","text":"grmploidyaware(\n    genomes::Genomes;\n    ploidy::Int64 = 2,\n    idx_entries::Union{Nothing,Vector{Int64}} = nothing,\n    idx_loci_alleles::Union{Nothing,Vector{Int64}} = nothing,\n    verbose::Bool = false\n)::Matrix{Float64}\n\nGenerate a ploidy-aware genetic relationship matrix (GRM) based on the methods described in  Bell et al. (2017) and VanRaden et al. (2008).\n\nArguments\n\ngenomes::Genomes: Input genomic data structure containing genetic information\nploidy::Int64: Number of chromosome copies in the organism (default: 2)\nidx_entries::Union{Nothing,Vector{Int64}}: Optional indices to select specific entries (default: nothing)\nidx_loci_alleles::Union{Nothing,Vector{Int64}}: Optional indices to select specific loci/alleles (default: nothing)\nverbose::Bool: If true, displays a heatmap of the resulting GRM (default: false)\n\nReturns\n\nMatrix{Float64}: A symmetric genetic relationship matrix with dimensions (n × n), where n is the number of entries\n\nDetails\n\nThe function implements the following steps:\n\nExtracts and processes genomic data\nCalculates allele frequencies and centers the data\nComputes the GRM using VanRaden's method\nEnsures matrix invertibility by adding small values to the diagonal if necessary\n\nNote\n\nThe diagonal elements may be slightly inflated to ensure matrix invertibility for downstream analyses.\n\nExample\n\njulia> genomes = GBCore.simulategenomes(verbose=false);\n\njulia> GRM_VanRaden = grmploidyaware(genomes);\n\njulia> size(GRM_VanRaden), issymmetric(GRM_VanRaden)\n((100, 100), true)\n\njulia> det(GRM_VanRaden) > eps(Float64)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GBModels.grmsimple-Tuple{GBCore.Genomes}","page":"Home","title":"GBModels.grmsimple","text":"grmsimple(\n    genomes::Genomes;\n    idx_entries::Union{Nothing,Vector{Int64}} = nothing,\n    idx_loci_alleles::Union{Nothing,Vector{Int64}} = nothing,\n    verbose::Bool = false\n)::Matrix{Float64}\n\nGenerate a simple genetic relationship matrix (GRM) from genomic data.\n\nArguments\n\ngenomes::Genomes: A Genomes object containing genetic information\nidx_entries::Union{Nothing,Vector{Int64}}: Optional indices to select specific entries/individuals\nidx_loci_alleles::Union{Nothing,Vector{Int64}}: Optional indices to select specific loci/alleles\nverbose::Bool: If true, displays a heatmap visualization of the GRM\n\nReturns\n\nMatrix{Float64}: A symmetric positive definite genetic relationship matrix\n\nDetails\n\nThe function computes a genetic relationship matrix by:\n\nConverting genomic data to a numerical matrix\nComputing GRM as G * G' / ncol(G)\nAdding small positive values to diagonal elements if necessary to ensure matrix invertibility\n\nNotes\n\nThe resulting matrix is always symmetric\nDiagonal elements may be slightly inflated to ensure matrix invertibility\nThe matrix dimensions will be n×n where n is the number of entries/individuals\n\nExample\n\njulia> genomes = GBCore.simulategenomes(verbose=false);\n\njulia> GRM = grmsimple(genomes);\n\njulia> size(GRM), issymmetric(GRM)\n((100, 100), true)\n\njulia> det(GRM) > eps(Float64)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GBModels.gwaslmm-Tuple{}","page":"Home","title":"GBModels.gwaslmm","text":"gwaslmm(\n    genomes::Genomes,\n    phenomes::Phenomes;\n    idx_entries::Union{Nothing,Vector{Int64}} = nothing,\n    idx_loci_alleles::Union{Nothing,Vector{Int64}} = nothing,\n    idx_trait::Int64 = 1,\n    GRM_type::String = [\"simple\", \"ploidy-aware\"][1],\n    verbose::Bool = false\n)::Fit\n\nPerform genome-wide association analysis using a linear mixed model (LMM) approach.\n\nArguments\n\ngenomes::Genomes: Genomic data structure containing genetic information\nphenomes::Phenomes: Phenotypic data structure containing trait measurements\nidx_entries::Union{Nothing,Vector{Int64}}: Optional indices for subsetting entries\nidx_loci_alleles::Union{Nothing,Vector{Int64}}: Optional indices for subsetting loci/alleles\nidx_trait::Int64: Index of the trait to analyze (default: 1)\nGRM_type::String: Type of genetic relationship matrix to use:\n\"simple\": Standard GRM calculation\n\"ploidy-aware\": Ploidy-adjusted GRM calculation\nverbose::Bool: Whether to display progress and plots (default: false)\n\nReturns\n\nFit: A structure containing GWAS results including:\nmodel: Model identifier (\"GWAS_LMM\")\nb_hat: Vector of test statistics (z-scores) for genetic markers\n\nDetails\n\nThe function implements a mixed model GWAS using the first principal component of the genetic  relationship matrix (GRM) as a fixed effect to control for population structure. The model  includes random effects for entries and uses REML estimation.\n\nNotes\n\nHandles both diploid and polyploid data through the GRM_type parameter\nUses multi-threading for parallel computation of marker effects\nIncludes automatic convergence retry on fitting failures\nMaximum fitting time per marker is limited to 60 seconds\n\nExamples\n\njulia> genomes = GBCore.simulategenomes(verbose=false);\n\njulia> ploidy = 4;\n\njulia> genomes.allele_frequencies = round.(genomes.allele_frequencies .* ploidy) ./ ploidy;\n\njulia> proportion_of_variance = zeros(9, 1); proportion_of_variance[1, 1] = 0.5;\n\njulia> trials, effects = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.05 0.00 0.00;], proportion_of_variance = proportion_of_variance, verbose=false);;\n\njulia> phenomes = extractphenomes(trials);\n\njulia> fit_1 = Suppressor.@suppress gwaslmm(genomes=genomes, phenomes=phenomes, GRM_type=\"simple\");\n\njulia> fit_1.model\n\"GWAS_LMM\"\n\njulia> fit_2 = Suppressor.@suppress gwaslmm(genomes=genomes, phenomes=phenomes, GRM_type=\"ploidy-aware\");\n\njulia> fit_2.model\n\"GWAS_LMM\"\n\njulia> findall(fit_1.b_hat .== maximum(fit_1.b_hat)) == findall(fit_2.b_hat .== maximum(fit_2.b_hat))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GBModels.gwasols-Tuple{}","page":"Home","title":"GBModels.gwasols","text":"gwasols(\n    genomes::Genomes,\n    phenomes::Phenomes;\n    idx_entries::Union{Nothing,Vector{Int64}} = nothing,\n    idx_loci_alleles::Union{Nothing,Vector{Int64}} = nothing,\n    idx_trait::Int64 = 1,\n    GRM_type::String = [\"simple\", \"ploidy-aware\"][1],\n    verbose::Bool = false,\n)::Fit\n\nPerform genome-wide association study (GWAS) using ordinary least squares (OLS) regression with population structure correction.\n\nArguments\n\ngenomes::Genomes: Genomic data structure containing genetic markers\nphenomes::Phenomes: Phenotypic data structure containing trait measurements\nidx_entries::Union{Nothing,Vector{Int64}}: Optional indices to subset entries (default: all entries)\nidx_loci_alleles::Union{Nothing,Vector{Int64}}: Optional indices to subset loci/alleles (default: all loci)\nidx_trait::Int64: Index of the trait to analyze (default: 1)\nGRM_type::String: Type of genetic relationship matrix to use (\"simple\" or \"ploidy-aware\") (default: \"simple\")\nverbose::Bool: Whether to display progress and plots (default: false)\n\nReturns\n\nFit: A structure containing GWAS results including:\nmodel: Model identifier (\"GWAS_OLS\")\nb_hat: Vector of effect size estimates/t-statistics for each marker\nAdditional model information\n\nDetails\n\nThe function implements GWAS using OLS regression while accounting for population structure through the first principal component of the genetic relationship matrix (GRM) as a covariate. Two types of GRM can be used: \"simple\" assumes diploid organisms, while \"ploidy-aware\" accounts for different ploidy levels.\n\nExamples\n\njulia> genomes = GBCore.simulategenomes(verbose=false);\n\njulia> ploidy = 4;\n\njulia> genomes.allele_frequencies = round.(genomes.allele_frequencies .* ploidy) ./ ploidy;\n\njulia> proportion_of_variance = zeros(9, 1); proportion_of_variance[1, 1] = 0.5;\n\njulia> trials, effects = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.05 0.00 0.00;], proportion_of_variance = proportion_of_variance, verbose=false);;\n\njulia> phenomes = extractphenomes(trials);\n\njulia> fit_1 = gwasols(genomes=genomes, phenomes=phenomes, GRM_type=\"simple\");\n\njulia> fit_1.model\n\"GWAS_OLS\"\n\njulia> fit_2 = gwasols(genomes=genomes, phenomes=phenomes, GRM_type=\"ploidy-aware\");\n\njulia> fit_2.model\n\"GWAS_OLS\"\n\njulia> findall(fit_1.b_hat .== maximum(fit_1.b_hat)) == findall(fit_2.b_hat .== maximum(fit_2.b_hat))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GBModels.gwasprep-Tuple{}","page":"Home","title":"GBModels.gwasprep","text":"gwasprep(\n    genomes::Genomes,\n    phenomes::Phenomes;\n    idx_entries::Union{Nothing,Vector{Int64}} = nothing,\n    idx_loci_alleles::Union{Nothing,Vector{Int64}} = nothing,\n    idx_trait::Int64 = 1,\n    GRM_type::String = [\"simple\", \"ploidy-aware\"][1],\n    standardise::Bool = true,\n    verbose::Bool = false,\n)::Tuple{Matrix{Float64},Vector{Float64},Matrix{Float64},Fit}\n\nPrepare data matrices and structures for genome-wide association studies (GWAS).\n\nArguments\n\ngenomes: Genomic data containing allele frequencies\nphenomes: Phenotypic data containing trait measurements\nidx_entries: Optional vector of indices to subset entries\nidx_loci_alleles: Optional vector of indices to subset loci/alleles\nidx_trait: Index of trait to analyze (default: 1)\nGRM_type: Type of genetic relationship matrix, either \"simple\" or \"ploidy-aware\"\nstandardise: Whether to standardize the data matrices (default: true)\nverbose: Whether to print progress information (default: false)\n\nReturns\n\nA tuple containing:\n\nG: Standardized allele frequency matrix\ny: Standardized phenotype vector  \nGRM: Genetic relationship matrix\nfit: Initialized Fit struct for GWAS results\n\nDetails\n\nPerforms data validation and preprocessing for GWAS analysis\nRemoves fixed loci with no variation\nStandardizes genomic and phenotypic data if requested\nConstructs appropriate genetic relationship matrix\nInitializes output structure for association results\n\nExamples\n\njulia> genomes = GBCore.simulategenomes(verbose=false);\n\njulia> ploidy = 4;\n\njulia> genomes.allele_frequencies = round.(genomes.allele_frequencies .* ploidy) ./ ploidy;\n\njulia> proportion_of_variance = zeros(9, 1); proportion_of_variance[1, 1] = 0.5;\n\njulia> trials, effects = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.05 0.00 0.00;], proportion_of_variance = proportion_of_variance, verbose=false);;\n\njulia> phenomes = extractphenomes(trials);\n\njulia> G, y, GRM, fit = gwasprep(genomes=genomes, phenomes=phenomes);\n\njulia> sum(abs.(mean(G, dims=1)[1,:]) .< 1e-10) == size(G, 2)\ntrue\n\njulia> sum(abs.(std(G, dims=1)[1,:] .- 1) .< 1e-10) == size(G, 2)\ntrue\n\njulia> (abs(mean(y)) < 1e-10, abs(std(y) - 1) < 1e-10)\n(true, true)\n\njulia> size(G, 1) == length(y)\ntrue\n\njulia> (size(G, 1), length(y)) == size(GRM)\ntrue\n\njulia> length(fit.entries) == length(y)\ntrue\n\njulia> length(fit.b_hat) == size(G, 2)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GBModels.gwasreml-Tuple{}","page":"Home","title":"GBModels.gwasreml","text":"gwasreml(\n    genomes::Genomes,\n    phenomes::Phenomes;\n    idx_entries::Union{Nothing,Vector{Int64}} = nothing,\n    idx_loci_alleles::Union{Nothing,Vector{Int64}} = nothing,\n    idx_trait::Int64 = 1,\n    GRM_type::String = \"simple\",\n    verbose::Bool = false\n)::Fit\n\nPerforms genome-wide association analysis using restricted maximum likelihood estimation (REML).\n\nArguments\n\ngenomes::Genomes: Genomic data structure containing genetic markers\nphenomes::Phenomes: Phenotypic data structure containing trait measurements\nidx_entries::Union{Nothing,Vector{Int64}}: Optional indices to subset entries (default: nothing)\nidx_loci_alleles::Union{Nothing,Vector{Int64}}: Optional indices to subset loci/alleles (default: nothing)\nidx_trait::Int64: Index of the trait to analyze (default: 1)\nGRM_type::String: Type of genetic relationship matrix to use, either \"simple\" or \"ploidy-aware\" (default: \"simple\")\nverbose::Bool: Whether to display progress and plots (default: false)\n\nReturns\n\n::Fit: A Fit struct containing GWAS results, including effect estimates and test statistics\n\nDetails\n\nImplements the REML log-likelihood calculation for a mixed model of the form: y = Xβ + Zu + e where:\n\nβ are fixed effects\nu are random genetic effects with u ~ N(0, σ²_u * GRM)\ne are residual effects with e ~ N(0, σ²_e * I)\n\nThe function constructs the variance-covariance matrices and computes the REML transformation to obtain the log-likelihood value used in variance component estimation.\n\nExamples\n\njulia> genomes = GBCore.simulategenomes(l=1_000, verbose=false);\n\njulia> ploidy = 4;\n\njulia> genomes.allele_frequencies = round.(genomes.allele_frequencies .* ploidy) ./ ploidy;\n\njulia> proportion_of_variance = zeros(9, 1); proportion_of_variance[1, 1] = 0.5;\n\njulia> trials, effects = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.05 0.00 0.00;], proportion_of_variance = proportion_of_variance, verbose=false);;\n\njulia> phenomes = extractphenomes(trials);\n\njulia> fit_1 = gwasreml(genomes=genomes, phenomes=phenomes, GRM_type=\"simple\");\n\njulia> fit_1.model\n\"GWAS_REML\"\n\njulia> fit_2 = gwasreml(genomes=genomes, phenomes=phenomes, GRM_type=\"ploidy-aware\");\n\njulia> fit_2.model\n\"GWAS_REML\"\n\njulia> findall(fit_1.b_hat .== maximum(fit_1.b_hat)) == findall(fit_2.b_hat .== maximum(fit_2.b_hat))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GBModels.invoneplus-Tuple{Any}","page":"Home","title":"GBModels.invoneplus","text":"invoneplus(x) = sqrt(abs(x))\n\nAn endofunction within the zero to one domain which accepts a single input and takes the inverse of one plus the input.\n\n\n\n\n\n","category":"method"},{"location":"#GBModels.lasso-Tuple{}","page":"Home","title":"GBModels.lasso","text":"lasso(;\n    genomes::Genomes,\n    phenomes::Phenomes,\n    idx_entries::Union{Nothing,Vector{Int64}} = nothing,\n    idx_loci_alleles::Union{Nothing,Vector{Int64}} = nothing,\n    idx_trait::Int64 = 1,\n    verbose::Bool = false,\n)::Fit\n\nFit a LASSO (least absolute shrinkage and selection operator; L1) regression model\n\nExamples\n\njulia> genomes = GBCore.simulategenomes(verbose=false);\n\njulia> trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);;\n\njulia> phenomes = extractphenomes(trials);\n\njulia> fit = lasso(genomes=genomes, phenomes=phenomes);\n\njulia> fit.model == \"lasso\"\ntrue\n\njulia> fit.metrics[\"cor\"] > 0.50\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GBModels.log10epsdivlog10eps-Tuple{Any}","page":"Home","title":"GBModels.log10epsdivlog10eps","text":"log10epsdivlog10eps(x)\n\nAn endofunction within the zero to one domain which accepts a single input and take its log10 corrected by machine epsilon to keep it in the domain.\n\n\n\n\n\n","category":"method"},{"location":"#GBModels.loglikreml-Tuple{Vector{Float64}, Tuple{Vector{Float64}, Matrix{Float64}, Matrix{Float64}}}","page":"Home","title":"GBModels.loglikreml","text":"loglikreml(θ::Vector{Float64}, data::Tuple{Vector{Float64},Matrix{Float64},Matrix{Float64}})::Float64\n\nCalculate the restricted maximum likelihood (REML) log-likelihood for a mixed linear model.\n\nArguments\n\nθ::Vector{Float64}: Vector of variance components [σ²e, σ²u] where:\nσ²_e is the residual variance\nσ²_u is the genetic variance\ndata::Tuple{Vector{Float64},Matrix{Float64},Matrix{Float64}}: Tuple containing:\ny: Vector of phenotypic observations\nX: Design matrix for fixed effects\nGRM: Genomic relationship matrix\n\nReturns\n\nFloat64: The REML log-likelihood value. Returns Inf if matrix operations fail.\n\nDetails\n\nImplements the REML log-likelihood calculation for a mixed model of the form: y = Xβ + Zu + e where:\n\nβ are fixed effects\nu are random genetic effects with u ~ N(0, σ²_u * GRM)\ne are residual effects with e ~ N(0, σ²_e * I)\n\nThe function constructs the variance-covariance matrices and computes the REML transformation to obtain the log-likelihood value used in variance component estimation.\n\nExamples\n\n```jldoctest; setup = :(using GBCore, GBModels, LinearAlgebra, StatsBase) julia> genomes = GBCore.simulategenomes(verbose=false);\n\njulia> ploidy = 4;\n\njulia> genomes.allelefrequencies = round.(genomes.allelefrequencies .* ploidy) ./ ploidy;\n\njulia> proportionofvariance = zeros(9, 1); proportionofvariance[1, 1] = 0.5;\n\njulia> trials, effects = GBCore.simulatetrials(genomes=genomes, nyears=1, nseasons=1, nharvests=1, nsites=1, nreplications=1, fadddomepi=[0.05 0.00 0.00;], proportionofvariance = proportionofvariance, verbose=false);;\n\njulia> phenomes = extractphenomes(trials);\n\njulia> G, y, GRM, fit = gwasprep(genomes=genomes, phenomes=phenomes);\n\njulia> loglik = loglikreml([0.53, 0.15], (y, hcat(ones(length(y)), G[:, 1]), GRM));\n\njulia> loglik < 100 true\n\n\n\n\n\n","category":"method"},{"location":"#GBModels.mult-Tuple{Any, Any}","page":"Home","title":"GBModels.mult","text":"mult(x, y) = x * y\n\nAn endofunction within the zero to one domain which accepts two inputs and multiplies them.\n\n\n\n\n\n","category":"method"},{"location":"#GBModels.ols-Tuple{}","page":"Home","title":"GBModels.ols","text":"ols(;\n    genomes::Genomes,\n    phenomes::Phenomes,\n    idx_entries::Union{Nothing,Vector{Int64}} = nothing,\n    idx_loci_alleles::Union{Nothing,Vector{Int64}} = nothing,\n    idx_trait::Int64 = 1,\n    verbose::Bool = false\n)::Fit\n\nFits an ordinary least squares (OLS) regression model to genomic and phenotypic data.\n\nArguments\n\ngenomes::Genomes: Genomic data containing genetic markers\nphenomes::Phenomes: Phenotypic data containing trait measurements\nidx_entries::Union{Nothing,Vector{Int64}}: Optional indices to select specific entries (default: all entries)\nidx_loci_alleles::Union{Nothing,Vector{Int64}}: Optional indices to select specific loci-alleles (default: all loci-alleles)\nidx_trait::Int64: Index of the trait to analyze (default: 1)\nverbose::Bool: If true, displays diagnostic plots and performance metrics (default: false)\n\nReturns\n\nFit: A fitted model object containing:\nmodel: Model identifier (\"ols\")\nb_hat: Estimated regression coefficients\nb_hat_labels: Labels for the coefficients\ny_true: Observed phenotypic values\ny_pred: Predicted phenotypic values\nmetrics: Dictionary of performance metrics\ntrait: Name of the analyzed trait\nentries: Entry identifiers\npopulations: Population identifiers\n\nDescription\n\nPerforms ordinary least squares regression on genomic data to predict phenotypic values. The model includes an intercept term and estimates effects for each locus-allele combination.\n\nExamples\n\njulia> genomes = GBCore.simulategenomes(verbose=false);\n\njulia> trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);;\n\njulia> phenomes = extractphenomes(trials);\n\njulia> fit = ols(genomes=genomes, phenomes=phenomes);\n\njulia> fit.model == \"ols\"\ntrue\n\njulia> fit.metrics[\"cor\"] > 0.50\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GBModels.predict-Tuple{}","page":"Home","title":"GBModels.predict","text":"predict(; fit::Fit, genomes::Genomes, idx_entries::Vector{Int64})::Vector{Float64}\n\nPredict the phenotypes given a genomic prediction model fit, a genomes and the corresponding entries indexes\n\nExamples\n\njulia> genomes = GBCore.simulategenomes(verbose=false);\n\njulia> trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);\n\njulia> phenomes = extractphenomes(trials);\n\njulia> fit = ridge(genomes=genomes, phenomes=phenomes, idx_entries=collect(1:90));\n\njulia> y_hat = GBModels.predict(fit=fit, genomes=genomes, idx_entries=collect(91:100));\n\njulia> cor(phenomes.phenotypes[91:100, 1], y_hat) > 0.5\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GBModels.raise-Tuple{Any, Any}","page":"Home","title":"GBModels.raise","text":"raise(x, y) = x^y\n\nAn endofunction within the zero to one domain which accepts two inputs, and raises the first to the power of the second.\n\n\n\n\n\n","category":"method"},{"location":"#GBModels.reconstitutefeatures-Tuple{GBCore.Genomes}","page":"Home","title":"GBModels.reconstitutefeatures","text":"reconstitutefeatures(\n    genomes::Genomes;\n    feature_names::Vector{String},\n    transformations1::Vector{Function} = [square, invoneplus, log10epsdivlog10eps],\n    transformations2::Vector{Function} = [mult, addnorm, raise],\n    verbose::Bool = false,\n)::Genomes\n\nReconstitute epistasis features given a genomes struct and names of the features which include the endofunction names used.\n\nExample\n\njulia> genomes = GBCore.simulategenomes(l=1_000, verbose=false);\n\njulia> trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);;\n\njulia> phenomes = extractphenomes(trials);\n\njulia> genomes_epifeat = epistasisfeatures(genomes, phenomes, n_new_features_per_transformation=50, n_reps=2, verbose=false);\n\njulia> feature_names = genomes_epifeat.loci_alleles;\n\njulia> genomes_epifeat_reconstructed = reconstitutefeatures(genomes, feature_names=feature_names);\n\njulia> genomes_epifeat == genomes_epifeat_reconstructed\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GBModels.ridge-Tuple{}","page":"Home","title":"GBModels.ridge","text":"ridge(;\n    genomes::Genomes,\n    phenomes::Phenomes,\n    idx_entries::Union{Nothing,Vector{Int64}} = nothing,\n    idx_loci_alleles::Union{Nothing,Vector{Int64}} = nothing,\n    idx_trait::Int64 = 1,\n    verbose::Bool = false\n)::Fit\n\nFit a ridge (L2) regression model to genomic data. Ridge regression adds an L2 regularization term  to the ordinary least squares objective function, which helps prevent overfitting and handles  multicollinearity in the predictors.\n\nArguments\n\ngenomes::Genomes: Genomic data structure containing genetic markers\nphenomes::Phenomes: Phenotypic data structure containing trait measurements\nidx_entries::Union{Nothing,Vector{Int64}}: Optional indices to subset specific entries/individuals\nidx_loci_alleles::Union{Nothing,Vector{Int64}}: Optional indices to subset specific loci-alleles\nidx_trait::Int64: Index of the trait to analyze (default: 1)\nverbose::Bool: If true, prints diagnostic plots and additional information (default: false)\n\nReturns\n\nFit: A structure containing:\nmodel: Model name (\"ridge\")\nb_hat: Estimated coefficients (including intercept)\nb_hat_labels: Labels for the coefficients\nmetrics: Performance metrics including correlation and error measures\ny_true: Observed phenotypic values\ny_pred: Predicted phenotypic values\nOther model metadata\n\nNotes\n\nUses cross-validation to select the optimal regularization parameter (λ)\nStandardizes predictors before fitting\nIncludes an intercept term in the model\n\nExamples\n\njulia> genomes = GBCore.simulategenomes(verbose=false);\n\njulia> trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);;\n\njulia> phenomes = extractphenomes(trials);\n\njulia> fit = ridge(genomes=genomes, phenomes=phenomes);\n\njulia> fit.model == \"ridge\"\ntrue\n\njulia> fit.metrics[\"cor\"] > 0.50\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GBModels.square-Tuple{Any}","page":"Home","title":"GBModels.square","text":"square(x) = x^2\n\nAn endofunction within the zero to one domain which accepts a single input and squares it.\n\n\n\n\n\n","category":"method"},{"location":"#GBModels.transform1-Tuple{Function, GBCore.Genomes, GBCore.Phenomes}","page":"Home","title":"GBModels.transform1","text":"transform1(\n    f::Function,\n    genomes::Genomes,\n    phenomes::Phenomes;\n    idx_trait::Int64 = 1,\n    idx_entries::Union{Nothing,Vector{Int64}} = nothing,\n    idx_loci_alleles::Union{Nothing,Vector{Int64}} = nothing,\n    n_new_features_per_transformation::Int64 = 1_000,\n    ϵ::Float64 = eps(Float64),\n    use_abs::Bool = false,\n    σ²_threshold::Float64 = 0.01,\n    verbose::Bool = false,\n)::Genomes\n\nApply a function to each allele frequency in genomes. Please Use named functions if you wish to reconstruct the transformation from the loci_alleles field.\n\nExample\n\njulia> genomes = GBCore.simulategenomes(l=1_000, verbose=false);\n\njulia> trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);;\n\njulia> phenomes = extractphenomes(trials);\n\njulia> genomes_transformed = transform1(x -> x^2, genomes, phenomes);\n\njulia> idx = findall(genomes.loci_alleles .== split(split(replace(genomes_transformed.loci_alleles[1], \")\" => \"\"), \"(\")[2], \",\")[1])[1];\n\njulia> mean(sqrt.(genomes_transformed.allele_frequencies[:, 1]) .- genomes.allele_frequencies[:, idx]) < 1e-10\ntrue\n\njulia> squareaddpi(x) = x^2 + pi;\n\njulia> genomes_transformed = transform1(squareaddpi, genomes, phenomes);\n\njulia> idx = findall(genomes.loci_alleles .== split(split(replace(genomes_transformed.loci_alleles[1], \")\" => \"\"), \"(\")[2], \",\")[1])[1];\n\njulia> mean(squareaddpi.(genomes.allele_frequencies[:, idx]) .- genomes_transformed.allele_frequencies[:, 1]) < 1e-10\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GBModels.transform2-Tuple{Function, GBCore.Genomes, GBCore.Phenomes}","page":"Home","title":"GBModels.transform2","text":"transform2(\n    f::Function,\n    genomes::Genomes,\n    phenomes::Phenomes;\n    idx_trait::Int64 = 1,\n    idx_entries::Union{Nothing,Vector{Int64}} = nothing,\n    idx_loci_alleles::Union{Nothing,Vector{Int64}} = nothing,\n    n_new_features_per_transformation::Int64 = 1_000,\n    ϵ::Float64 = eps(Float64),\n    use_abs::Bool = false,\n    σ²_threshold::Float64 = 0.01,\n    commutative::Bool = false,\n    verbose::Bool = false,\n)::Genomes\n\nApply a function to pairs of allele frequency in genomes. Please Use named functions if you wish to reconstruct the transformation from the loci_alleles field.\n\nExample\n\njulia> genomes = GBCore.simulategenomes(l=1_000, verbose=false);\n\njulia> trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);;\n\njulia> phenomes = extractphenomes(trials);\n\njulia> genomes_transformed = transform2((x,y) -> (x^2 + sqrt(y)) / 2, genomes, phenomes);\n\njulia> idx_1 = findall(genomes.loci_alleles .== split(split(replace(genomes_transformed.loci_alleles[1], \")\" => \"\"), \"(\")[2], \",\")[1])[1];\n\njulia> idx_2 = findall(genomes.loci_alleles .== split(split(replace(genomes_transformed.loci_alleles[1], \")\" => \"\"), \"(\")[2], \",\")[2])[1];\n\njulia> mean((genomes.allele_frequencies[:,idx_1].^2 .+ sqrt.(genomes.allele_frequencies[:,idx_2])) ./ 2 .- genomes_transformed.allele_frequencies[:,1]) < 1e-10\ntrue\n\njulia> raisexbyythenlog(x, y) = log(abs(x^y));\n\njulia> genomes_transformed = transform2(raisexbyythenlog, genomes, phenomes);\n\njulia> idx_1 = findall(genomes.loci_alleles .== split(split(replace(genomes_transformed.loci_alleles[1], \")\" => \"\"), \"(\")[2], \",\")[1])[1];\n\njulia> idx_2 = findall(genomes.loci_alleles .== split(split(replace(genomes_transformed.loci_alleles[1], \")\" => \"\"), \"(\")[2], \",\")[2])[1];\n\njulia> mean(raisexbyythenlog.(genomes.allele_frequencies[:,idx_1], genomes.allele_frequencies[:,idx_2]) .- genomes_transformed.allele_frequencies[:,1]) < 1e-10\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GBModels.turing_bayesG-Tuple{Any, Any}","page":"Home","title":"GBModels.turing_bayesG","text":"Turing specification of Bayesian linear regression using a Gaussian prior with common variance\n\nExample usage\n\n# Benchmarking\ngenomes = GBCore.simulategenomes(n=10, l=100)\ntrials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.9 0.01 0.00;])\nphenomes = extractphenomes(trials)\nG::Matrix{Float64} = genomes.allele_frequencies\ny::Vector{Float64} = phenomes.phenotypes[:, 1]\nmodel = turing_bayesG(G, y)\nbenchmarks = TuringBenchmarking.benchmark_model(\n    model;\n    # Check correctness of computations\n    check=true,\n    # Automatic differentiation backends to check and benchmark\n    adbackends=[:forwarddiff, :reversediff, :reversediff_compiled, :zygote]\n)\n\n# Test more loci\ngenomes = GBCore.simulategenomes(n=10, l=10_000)\ntrials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.9 0.01 0.00;])\nphenomes = extractphenomes(trials)\nG::Matrix{Float64} = genomes.allele_frequencies\ny::Vector{Float64} = phenomes.phenotypes[:, 1]\n# Check for uninferred types in the model\n@code_warntype model = turing_bayesG(G, y)\n# Fit\nmodel = turing_bayesG(G, y)\n# We use compile=true in AutoReverseDiff() because we do not have any if-statements in our Turing model below\nrng::TaskLocalRNG = Random.seed!(123)\nniter::Int64 = 1_500\nnburnin::Int64 = 500\n@time chain = Turing.sample(rng, model, NUTS(nburnin, 0.65, max_depth=5, Δ_max=1000.0, init_ϵ=0.2; adtype=AutoReverseDiff(compile=true)), niter-nburnin, progress=true);\n# @time chain = Turing.sample(rng, model, HMC(0.05, 10; adtype=AutoReverseDiff(compile=true)), niter, progress=true);\np = Plots.histogram(chain[:σ²])\nPlots.gui(p)\n# Use the mean paramter values after 150 burn-in iterations\nparams = Turing.get_params(chain[501:end, :, :]);\nb_hat = vcat(mean(params.intercept), mean(stack(params.coefficients, dims=1)[:, :, 1], dims=2)[:,1]);\n# Assess prediction accuracy\ny_pred::Vector{Float64} = hcat(ones(size(G,1)), G) * b_hat;\nUnicodePlots.scatterplot(y, y_pred)\nperformance::Dict{String, Float64} = metrics(y, y_pred)\n\n\n\n\n\n","category":"method"},{"location":"#GBModels.turing_bayesG_logit-Tuple{Any, Any}","page":"Home","title":"GBModels.turing_bayesG_logit","text":"Turing specification of Bayesian logistic regression using a Gaussian prior with common variance\n\n\n\n\n\n","category":"method"},{"location":"#GBModels.turing_bayesGs-Tuple{Any, Any}","page":"Home","title":"GBModels.turing_bayesGs","text":"Turing specification of Bayesian linear regression using a Gaussian prior with varying variances\n\nExample usage\n\n# Simulate data\ngenomes = GBCore.simulategenomes(n=10, l=100)\ntrials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.9 0.01 0.00;])\nphenomes = extractphenomes(trials)\n# Extract genotype and phenotype data\nG::Matrix{Float64} = genomes.allele_frequencies\ny::Vector{Float64} = phenomes.phenotypes[:, 1]\n# Regress for just 200 iterations for demonstration purposes only. Use way way more iterations, e.g. 10,000.\nmodel = turing_bayesGs(G, y)\n# We use compile=true in AutoReverseDiff() because we do not have any if-statements in our Turing model below\nrng::TaskLocalRNG = Random.seed!(123)\nniter::Int64 = 1_500\nnburnin::Int64 = 500\n@time chain = Turing.sample(rng, model, NUTS(nburnin, 0.5, max_depth=5, Δ_max=1000.0, init_ϵ=0.2; adtype=AutoReverseDiff(compile=true)), niter-nburnin, progress=true);\n# Use the mean paramter values after 150 burn-in iterations\nparams = Turing.get_params(chain[150:end, :, :]);\nb_hat = vcat(mean(params.intercept), mean(stack(params.coefficients, dims=1)[:, :, 1], dims=2)[:,1]);\n# Assess prediction accuracy\ny_pred::Vector{Float64} = hcat(ones(size(G,1)), G) * b_hat;\nUnicodePlots.scatterplot(y, y_pred)\nperformance::Dict{String, Float64} = metrics(y, y_pred)\n\n\n\n\n\n","category":"method"},{"location":"#GBModels.turing_bayesGπ-Tuple{Any, Any}","page":"Home","title":"GBModels.turing_bayesGπ","text":"Turing specification of Bayesian linear regression using a Gaussian prior with a point mass at zero and common variance\n\nExample usage\n\n# Simulate data\ngenomes = GBCore.simulategenomes(n=10, l=100)\ntrials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.9 0.01 0.00;])\nphenomes = extractphenomes(trials)\n# Extract genotype and phenotype data\nG::Matrix{Float64} = genomes.allele_frequencies\ny::Vector{Float64} = phenomes.phenotypes[:, 1]\n# Regress for just 200 iterations for demonstration purposes only. Use way way more iterations, e.g. 10,000.\nmodel = turing_bayesGπ(G, y)\n# We use compile=true in AutoReverseDiff() because we do not have any if-statements in our Turing model below\nrng::TaskLocalRNG = Random.seed!(123)\nniter::Int64 = 1_500\nnburnin::Int64 = 500\n@time chain = Turing.sample(rng, model, NUTS(nburnin, 0.5, max_depth=5, Δ_max=1000.0, init_ϵ=0.2; adtype=AutoReverseDiff(compile=true)), niter-nburnin, progress=true);\n# Use the mean paramter values after 150 burn-in iterations\nparams = Turing.get_params(chain[150:end, :, :]);\nb_hat = vcat(mean(params.intercept), mean(stack(params.coefficients, dims=1)[:, :, 1], dims=2)[:,1]);\n# Assess prediction accuracy\ny_pred::Vector{Float64} = hcat(ones(size(G,1)), G) * b_hat;\nUnicodePlots.scatterplot(y, y_pred)\nperformance::Dict{String, Float64} = metrics(y, y_pred)\n\n\n\n\n\n","category":"method"},{"location":"#GBModels.turing_bayesGπs-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, DynamicPPL.TypeWrap{T}}} where T","page":"Home","title":"GBModels.turing_bayesGπs","text":"Turing specification of Bayesian linear regression using a Gaussian prior with a point mass at zero and varying variances\n\nExample usage\n\n# Simulate data\ngenomes = GBCore.simulategenomes(n=10, l=100)\ntrials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.9 0.01 0.00;])\nphenomes = extractphenomes(trials)\n# Extract genotype and phenotype data\nG::Matrix{Float64} = genomes.allele_frequencies\ny::Vector{Float64} = phenomes.phenotypes[:, 1]\n# Regress for just 200 iterations for demonstration purposes only. Use way way more iterations, e.g. 10,000.\nmodel = turing_bayesGπs(G, y)\n# We use compile=true in AutoReverseDiff() because we do not have any if-statements in our Turing model below\nrng::TaskLocalRNG = Random.seed!(123)\nniter::Int64 = 1_500\nnburnin::Int64 = 500\n@time chain = Turing.sample(rng, model, NUTS(nburnin, 0.5, max_depth=5, Δ_max=1000.0, init_ϵ=0.2; adtype=AutoReverseDiff(compile=true)), niter-nburnin, progress=true);\n# Use the mean paramter values after 150 burn-in iterations\nparams = Turing.get_params(chain[150:end, :, :]);\nb_hat = vcat(mean(params.intercept), mean(stack(params.coefficients, dims=1)[:, :, 1], dims=2)[:,1]);\n# Assess prediction accuracy\ny_pred::Vector{Float64} = hcat(ones(size(G,1)), G) * b_hat;\nUnicodePlots.scatterplot(y, y_pred)\nperformance::Dict{String, Float64} = metrics(y, y_pred)\n\n\n\n\n\n","category":"method"},{"location":"#GBModels.turing_bayesL-Tuple{Any, Any}","page":"Home","title":"GBModels.turing_bayesL","text":"Turing specification of Bayesian linear regression using a Laplacian prior with a common scale\n\nExample usage\n\n# Simulate data\ngenomes = GBCore.simulategenomes(n=10, l=100)\ntrials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.9 0.01 0.00;])\nphenomes = extractphenomes(trials)\n# Extract genotype and phenotype data\nG::Matrix{Float64} = genomes.allele_frequencies\ny::Vector{Float64} = phenomes.phenotypes[:, 1]\n# Regress for just 200 iterations for demonstration purposes only. Use way way more iterations, e.g. 10,000.\nmodel = turing_bayesL(G, y)\n# We use compile=true in AutoReverseDiff() because we do not have any if-statements in our Turing model below\nrng::TaskLocalRNG = Random.seed!(123)\nniter::Int64 = 1_500\nnburnin::Int64 = 500\n@time chain = Turing.sample(rng, model, NUTS(nburnin, 0.5, max_depth=5, Δ_max=1000.0, init_ϵ=0.2; adtype=AutoReverseDiff(compile=true)), niter-nburnin, progress=true);\n# Use the mean paramter values after 150 burn-in iterations\nparams = Turing.get_params(chain[150:end, :, :]);\nb_hat = vcat(mean(params.intercept), mean(stack(params.coefficients, dims=1)[:, :, 1], dims=2)[:,1]);\n# Assess prediction accuracy\ny_pred::Vector{Float64} = hcat(ones(size(G,1)), G) * b_hat;\nUnicodePlots.scatterplot(y, y_pred)\nperformance::Dict{String, Float64} = metrics(y, y_pred)\n\n\n\n\n\n","category":"method"},{"location":"#GBModels.turing_bayesLs-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, DynamicPPL.TypeWrap{T}}} where T","page":"Home","title":"GBModels.turing_bayesLs","text":"Turing specification of Bayesian linear regression using a Laplacian prior with varying scales\n\nExample usage\n\n# Simulate data\ngenomes = GBCore.simulategenomes(n=10, l=100)\ntrials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.9 0.01 0.00;])\nphenomes = extractphenomes(trials)\n# Extract genotype and phenotype data\nG::Matrix{Float64} = genomes.allele_frequencies\ny::Vector{Float64} = phenomes.phenotypes[:, 1]\n# Regress for just 200 iterations for demonstration purposes only. Use way way more iterations, e.g. 10,000.\nmodel = turing_bayesLs(G, y)\n# We use compile=true in AutoReverseDiff() because we do not have any if-statements in our Turing model below\nrng::TaskLocalRNG = Random.seed!(123)\nniter::Int64 = 1_500\nnburnin::Int64 = 500\n@time chain = Turing.sample(rng, model, NUTS(nburnin, 0.5, max_depth=5, Δ_max=1000.0, init_ϵ=0.2; adtype=AutoReverseDiff(compile=true)), niter-nburnin, progress=true);\n# Use the mean paramter values after 150 burn-in iterations\nparams = Turing.get_params(chain[150:end, :, :]);\nb_hat = vcat(mean(params.intercept), mean(stack(params.coefficients, dims=1)[:, :, 1], dims=2)[:,1]);\n# Assess prediction accuracy\ny_pred::Vector{Float64} = hcat(ones(size(G,1)), G) * b_hat;\nUnicodePlots.scatterplot(y, y_pred)\nperformance::Dict{String, Float64} = metrics(y, y_pred)\n\n\n\n\n\n","category":"method"},{"location":"#GBModels.turing_bayesLπ-Tuple{Any, Any}","page":"Home","title":"GBModels.turing_bayesLπ","text":"Turing specification of Bayesian linear regression using a Laplacian prior with a point mass at zero and common scale\n\nExample usage\n\n# Simulate data\ngenomes = GBCore.simulategenomes(n=10, l=100)\ntrials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.9 0.01 0.00;])\nphenomes = extractphenomes(trials)\n# Extract genotype and phenotype data\nG::Matrix{Float64} = genomes.allele_frequencies\ny::Vector{Float64} = phenomes.phenotypes[:, 1]\n# Regress for just 200 iterations for demonstration purposes only. Use way way more iterations, e.g. 10,000.\nmodel = turing_bayesLπ(G, y)\n# We use compile=true in AutoReverseDiff() because we do not have any if-statements in our Turing model below\nrng::TaskLocalRNG = Random.seed!(123)\nniter::Int64 = 1_500\nnburnin::Int64 = 500\n@time chain = Turing.sample(rng, model, NUTS(nburnin, 0.5, max_depth=5, Δ_max=1000.0, init_ϵ=0.2; adtype=AutoReverseDiff(compile=true)), niter-nburnin, progress=true);\n# Use the mean paramter values after 150 burn-in iterations\nparams = Turing.get_params(chain[150:end, :, :]);\nb_hat = vcat(mean(params.intercept), mean(stack(params.coefficients, dims=1)[:, :, 1], dims=2)[:,1]);\n# Assess prediction accuracy\ny_pred::Vector{Float64} = hcat(ones(size(G,1)), G) * b_hat;\nUnicodePlots.scatterplot(y, y_pred)\nperformance::Dict{String, Float64} = metrics(y, y_pred)\n\n\n\n\n\n","category":"method"},{"location":"#GBModels.turing_bayesLπs-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, DynamicPPL.TypeWrap{T}}} where T","page":"Home","title":"GBModels.turing_bayesLπs","text":"Turing specification of Bayesian linear regression using a Laplacian prior with a point mass at zero and common scale\n\nExample usage\n\n# Simulate data\ngenomes = GBCore.simulategenomes(n=10, l=100)\ntrials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.9 0.01 0.00;])\nphenomes = extractphenomes(trials)\n# Extract genotype and phenotype data\nG::Matrix{Float64} = genomes.allele_frequencies\ny::Vector{Float64} = phenomes.phenotypes[:, 1]\n# Regress for just 200 iterations for demonstration purposes only. Use way way more iterations, e.g. 10,000.\nmodel = turing_bayesLπs(G, y)\n# We use compile=true in AutoReverseDiff() because we do not have any if-statements in our Turing model below\nrng::TaskLocalRNG = Random.seed!(123)\nniter::Int64 = 1_500\nnburnin::Int64 = 500\n@time chain = Turing.sample(rng, model, NUTS(nburnin, 0.5, max_depth=5, Δ_max=1000.0, init_ϵ=0.2; adtype=AutoReverseDiff(compile=true)), niter-nburnin, progress=true);\n# Use the mean paramter values after 150 burn-in iterations\nparams = Turing.get_params(chain[150:end, :, :]);\nb_hat = vcat(mean(params.intercept), mean(stack(params.coefficients, dims=1)[:, :, 1], dims=2)[:,1]);\n# Assess prediction accuracy\ny_pred::Vector{Float64} = hcat(ones(size(G,1)), G) * b_hat;\nUnicodePlots.scatterplot(y, y_pred)\nperformance::Dict{String, Float64} = metrics(y, y_pred)\n\n\n\n\n\n","category":"method"},{"location":"#GBModels.turing_bayesT-Tuple{Any, Any}","page":"Home","title":"GBModels.turing_bayesT","text":"Turing specification of Bayesian linear regression using a T-distribution\n\nExample usage\n\n# Simulate data\ngenomes = GBCore.simulategenomes(n=10, l=100)\ntrials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.9 0.01 0.00;])\nphenomes = extractphenomes(trials)\n# Extract genotype and phenotype data\nG::Matrix{Float64} = genomes.allele_frequencies\ny::Vector{Float64} = phenomes.phenotypes[:, 1]\n# Regress for just 200 iterations for demonstration purposes only. Use way way more iterations, e.g. 10,000.\nmodel = turing_bayesT(G, y)\n# We use compile=true in AutoReverseDiff() because we do not have any if-statements in our Turing model below\nrng::TaskLocalRNG = Random.seed!(123)\nniter::Int64 = 1_500\nnburnin::Int64 = 500\n@time chain = Turing.sample(rng, model, NUTS(nburnin, 0.5, max_depth=5, Δ_max=1000.0, init_ϵ=0.2; adtype=AutoReverseDiff(compile=true)), niter-nburnin, progress=true);\n# Use the mean paramter values after 150 burn-in iterations\nparams = Turing.get_params(chain[150:end, :, :]);\nb_hat = vcat(mean(params.intercept), mean(stack(params.coefficients, dims=1)[:, :, 1], dims=2)[:,1]);\n# Assess prediction accuracy\ny_pred::Vector{Float64} = hcat(ones(size(G,1)), G) * b_hat;\nUnicodePlots.scatterplot(y, y_pred)\nperformance::Dict{String, Float64} = metrics(y, y_pred)\n\n\n\n\n\n","category":"method"},{"location":"#GBModels.turing_bayesTπ-Tuple{Any, Any}","page":"Home","title":"GBModels.turing_bayesTπ","text":"Turing specification of Bayesian linear regression using a T-distribution with a point mass at zero\n\nExample usage\n\n# Simulate data\ngenomes = GBCore.simulategenomes(n=10, l=100)\ntrials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.9 0.01 0.00;])\nphenomes = extractphenomes(trials)\n# Extract genotype and phenotype data\nG::Matrix{Float64} = genomes.allele_frequencies\ny::Vector{Float64} = phenomes.phenotypes[:, 1]\n# Regress for just 200 iterations for demonstration purposes only. Use way way more iterations, e.g. 10,000.\nmodel = turing_bayesTπ(G, y)\n# We use compile=true in AutoReverseDiff() because we do not have any if-statements in our Turing model below\nrng::TaskLocalRNG = Random.seed!(123)\nniter::Int64 = 1_500\nnburnin::Int64 = 500\n@time chain = Turing.sample(rng, model, NUTS(nburnin, 0.5, max_depth=5, Δ_max=1000.0, init_ϵ=0.2; adtype=AutoReverseDiff(compile=true)), niter-nburnin, progress=true);\n# Use the mean paramter values after 150 burn-in iterations\nparams = Turing.get_params(chain[150:end, :, :]);\nb_hat = vcat(mean(params.intercept), mean(stack(params.coefficients, dims=1)[:, :, 1], dims=2)[:,1]);\n# Assess prediction accuracy\ny_pred::Vector{Float64} = hcat(ones(size(G,1)), G) * b_hat;\nUnicodePlots.scatterplot(y, y_pred)\nperformance::Dict{String, Float64} = metrics(y, y_pred)\n\n\n\n\n\n","category":"method"},{"location":"#GBModels.validate-Tuple{GBCore.Fit, GBCore.Genomes, GBCore.Phenomes}","page":"Home","title":"GBModels.validate","text":"validate(\n    fit::Fit,\n    genomes::Genomes,\n    phenomes::Phenomes;\n    idx_validation::Vector{Int64},\n    replication::String=\"\",\n    fold::String=\"\"\n)::CV\n\nEvaluate the predictive accuracy of a genomic prediction model on a validation dataset.\n\nArguments\n\nfit::Fit: A fitted genomic prediction model\ngenomes::Genomes: Genomic data containing marker information\nphenomes::Phenomes: Phenotypic data containing trait measurements\nidx_validation::Vector{Int64}: Indices of entries to use for validation\nreplication::String: Optional identifier for the validation replication\nfold::String: Optional identifier for the cross-validation fold\n\nReturns\n\nCV: A cross-validation result object containing:\nValidation metrics (correlation, RMSE, etc.)\nTrue and predicted values\nEntry and population information\nModel specifications\n\nNotes\n\nPerforms checks for data leakage between training and validation sets\nHandles missing, NaN, and Inf values in phenotypic data\nValidates dimensions of output CV struct\n\nExamples\n\njulia> genomes = GBCore.simulategenomes(verbose=false);\n\njulia> trials, _ = GBCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, f_add_dom_epi=[0.1 0.01 0.01;], verbose=false);\n\njulia> phenomes = extractphenomes(trials);\n\njulia> fit = ridge(genomes=genomes, phenomes=phenomes, idx_entries=collect(1:90));\n\njulia> cv = validate(fit, genomes, phenomes, idx_validation=collect(91:100));\n\njulia> cv.metrics[\"cor\"] > 0.50\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GBModels.@string2operations-Tuple{Any}","page":"Home","title":"GBModels.@string2operations","text":"string2operations(x)\n\nMacro to Meta.parse a string of endofunction formulae across allele frequencies.\n\n\n\n\n\n","category":"macro"}]
}
